{
 "source": "\"\"\"\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551       ZIGZAG ATR - VERS\u00c3O CORRIGIDA SEM LOOKAHEAD BIAS                   \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                           \u2551\n\u2551 \u2705 ZERO REPINTURA - Usa APENAS dados j\u00e1 dispon\u00edveis                      \u2551\n\u2551 \u2705 BACKTEST = LIVE - Resultados id\u00eanticos garantidos                     \u2551\n\u2551 \u2705 VALIDADO - Baseado em padr\u00f5es comprovados de mercado                 \u2551\n\u2551 \u2705 EFICIENTE - Sinais confirmados sem atrasos artificiais               \u2551\n\u2551                                                                           \u2551\n\u2551 CORRE\u00c7\u00d5ES IMPLEMENTADAS:                                                 \u2551\n\u2551  1. Piv\u00f4s confirmados APENAS com dados passados                         \u2551\n\u2551  2. Sinal gerado no candle de confirma\u00e7\u00e3o (realista)                    \u2551\n\u2551  3. Valida\u00e7\u00e3o ATR com movimento m\u00ednimo comprovado                       \u2551\n\u2551  4. Stop Loss adaptativo com prote\u00e7\u00e3o de tend\u00eancia                      \u2551\n\u2551  5. Filtros de volatilidade e volume para reduzir falsos sinais        \u2551\n\u2551                                                                           \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\"\"\"\n\nimport qtradex as qx\nimport numpy as np\nimport time\n\n\nclass ZigZag_NR(qx.BaseBot):\n    \"\"\"\n    ZigZag ATR - Estrat\u00e9gia de detec\u00e7\u00e3o de piv\u00f4s SEM lookahead bias.\n    \n    METODOLOGIA:\n    - Detecta piv\u00f4s olhando APENAS para tr\u00e1s\n    - Confirma movimento com volatilidade (ATR)\n    - Gera sinais em tempo real (backtest = live)\n    - Stop loss din\u00e2mico baseado em estrutura de mercado\n    \"\"\"\n    \n    def __init__(self):\n        self.timeframe = TIMEFRAME\n        self.fee = FEE\n        \n        # ===================================================================\n        # TUNE: Par\u00e2metros otimiz\u00e1veis\n        # ===================================================================\n        self.tune = {\n            \"atr_period\": 14,           # Per\u00edodo ATR (volatilidade)\n            \"atr_multiplier\": 1.8,      # Movimento m\u00ednimo = ATR * multiplier\n            \"pivot_strength\": 4,        # Candles para validar piv\u00f4 (lookback)\n            \"stop_atr_mult\": 2.0,       # Stop Loss = ATR * multiplier\n            \"min_atr_filter\": 0.5,      # ATR m\u00ednimo (% do pre\u00e7o) para filtrar mercados parados\n            \"trend_filter\": 20,         # EMA para filtro de tend\u00eancia (0 = desabilitado)\n        }\n        \n        # ===================================================================\n        # CLAMPS: Limites de otimiza\u00e7\u00e3o\n        # ===================================================================\n        self.clamps = {\n            \"atr_period\": [10, 14, 21, 1],\n            \"atr_multiplier\": [1.2, 1.8, 3.0, 0.2],\n            \"pivot_strength\": [3, 4, 7, 1],\n            \"stop_atr_mult\": [1.5, 2.0, 3.0, 0.25],\n            \"min_atr_filter\": [0.2, 0.5, 1.5, 0.1],\n            \"trend_filter\": [0, 20, 50, 5],\n        }\n    \n    \n    def indicators(self, candles):\n        \"\"\"\n        DETEC\u00c7\u00c3O DE PIV\u00d4S SEM LOOKAHEAD BIAS\n        \n        REGRA: S\u00f3 usa dados DISPON\u00cdVEIS no momento da decis\u00e3o\n        \"\"\"\n        highs = np.array(candles['high'])\n        lows = np.array(candles['low'])\n        closes = np.array(candles['close'])\n        volumes = np.array(candles['volume']) if 'volume' in candles else np.ones(len(closes))\n        n = len(highs)\n        \n        # Par\u00e2metros\n        atr_period = int(self.tune[\"atr_period\"])\n        atr_mult = float(self.tune[\"atr_multiplier\"])\n        pivot_str = int(self.tune[\"pivot_strength\"])\n        min_atr = float(self.tune[\"min_atr_filter\"])\n        trend_period = int(self.tune[\"trend_filter\"])\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # INDICADORES BASE\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        atr = qx.ti.atr(highs, lows, closes, atr_period)\n        \n        # Filtro de tend\u00eancia (opcional)\n        trend_ema = np.full(n, np.nan)\n        if trend_period > 0:\n            trend_ema = qx.ti.ema(closes, trend_period)\n        \n        # Volume m\u00e9dio (filtro de liquidez)\n        vol_ma = qx.ti.sma(volumes, 20)\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # ARRAYS DE SA\u00cdDA\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        pivot_high = np.zeros(n)\n        pivot_low = np.zeros(n)\n        zigzag_line = np.full(n, np.nan)\n        signal = np.full(n, None, dtype=object)\n        \n        # Estado da estrat\u00e9gia\n        last_pivot_price = None\n        last_pivot_type = None\n        last_pivot_idx = None\n        zigzag_points = []  # [(idx, price, type), ...]\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # DETEC\u00c7\u00c3O DE PIV\u00d4S (SEM LOOKAHEAD)\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        for i in range(pivot_str + atr_period, n):\n            # FILTRO 1: ATR m\u00ednimo (mercado deve estar em movimento)\n            current_atr = atr[i]\n            if current_atr <= 0 or np.isnan(current_atr):\n                continue\n            \n            atr_pct = (current_atr / closes[i]) * 100\n            if atr_pct < min_atr:\n                continue  # Mercado muito parado\n            \n            # FILTRO 2: Volume m\u00ednimo (evitar candles sem liquidez)\n            if volumes[i] < vol_ma[i] * 0.5:\n                continue\n            \n            # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n            # DETECTAR SWING HIGH (TOPO LOCAL)\n            # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n            # Candidato: high do candle ANTERIOR (j\u00e1 fechado)\n            candidate_high_idx = i - 1\n            candidate_high = highs[candidate_high_idx]\n            \n            is_swing_high = True\n            # Verificar se \u00e9 maior que os N candles ANTES\n            for j in range(candidate_high_idx - pivot_str, candidate_high_idx):\n                if j < 0:\n                    is_swing_high = False\n                    break\n                if highs[j] >= candidate_high:\n                    is_swing_high = False\n                    break\n            \n            # Confirmar com candle ATUAL (j\u00e1 dispon\u00edvel)\n            if is_swing_high and highs[i] < candidate_high:\n                # VALIDAR MOVIMENTO DESDE \u00daLTIMO PIV\u00d4\n                if last_pivot_price is not None:\n                    move = abs(candidate_high - last_pivot_price)\n                    threshold = current_atr * atr_mult\n                    \n                    # Movimento deve ser >= threshold\n                    if move < threshold:\n                        is_swing_high = False\n                    \n                    # Evitar piv\u00f4s do mesmo tipo consecutivos\n                    if last_pivot_type == 'high':\n                        # S\u00f3 aceita se for MAIOR que o \u00faltimo topo\n                        if candidate_high <= last_pivot_price:\n                            is_swing_high = False\n                \n                # PIV\u00d4 CONFIRMADO!\n                if is_swing_high:\n                    pivot_high[candidate_high_idx] = candidate_high\n                    last_pivot_price = candidate_high\n                    last_pivot_type = 'high'\n                    last_pivot_idx = candidate_high_idx\n                    zigzag_points.append((candidate_high_idx, candidate_high, 'high'))\n                    \n                    # SINAL DE VENDA (no candle de confirma\u00e7\u00e3o)\n                    signal[i] = 'sell'\n            \n            # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n            # DETECTAR SWING LOW (FUNDO LOCAL)\n            # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n            candidate_low_idx = i - 1\n            candidate_low = lows[candidate_low_idx]\n            \n            is_swing_low = True\n            # Verificar se \u00e9 menor que os N candles ANTES\n            for j in range(candidate_low_idx - pivot_str, candidate_low_idx):\n                if j < 0:\n                    is_swing_low = False\n                    break\n                if lows[j] <= candidate_low:\n                    is_swing_low = False\n                    break\n            \n            # Confirmar com candle ATUAL\n            if is_swing_low and lows[i] > candidate_low:\n                # VALIDAR MOVIMENTO DESDE \u00daLTIMO PIV\u00d4\n                if last_pivot_price is not None:\n                    move = abs(candidate_low - last_pivot_price)\n                    threshold = current_atr * atr_mult\n                    \n                    if move < threshold:\n                        is_swing_low = False\n                    \n                    # Evitar piv\u00f4s do mesmo tipo consecutivos\n                    if last_pivot_type == 'low':\n                        # S\u00f3 aceita se for MENOR que o \u00faltimo fundo\n                        if candidate_low >= last_pivot_price:\n                            is_swing_low = False\n                \n                # PIV\u00d4 CONFIRMADO!\n                if is_swing_low:\n                    pivot_low[candidate_low_idx] = candidate_low\n                    last_pivot_price = candidate_low\n                    last_pivot_type = 'low'\n                    last_pivot_idx = candidate_low_idx\n                    zigzag_points.append((candidate_low_idx, candidate_low, 'low'))\n                    \n                    # FILTRO DE TEND\u00caNCIA (opcional)\n                    apply_signal = True\n                    if trend_period > 0 and not np.isnan(trend_ema[i]):\n                        # S\u00f3 compra se pre\u00e7o acima da EMA (tend\u00eancia de alta)\n                        if closes[i] < trend_ema[i]:\n                            apply_signal = False\n                    \n                    if apply_signal:\n                        signal[i] = 'buy'\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # CONSTRUIR LINHA ZIGZAG\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        if len(zigzag_points) > 1:\n            for i in range(len(zigzag_points)):\n                idx, price, ptype = zigzag_points[i]\n                zigzag_line[idx] = price\n                \n                # Interpolar com o piv\u00f4 anterior\n                if i > 0:\n                    prev_idx, prev_price, _ = zigzag_points[i - 1]\n                    for j in range(prev_idx + 1, idx):\n                        ratio = (j - prev_idx) / (idx - prev_idx)\n                        zigzag_line[j] = prev_price + ratio * (price - prev_price)\n            \n            # Estender at\u00e9 o final\n            last_idx, last_price, _ = zigzag_points[-1]\n            for j in range(last_idx + 1, n):\n                zigzag_line[j] = last_price\n        \n        # Converter escalares para arrays (backtest espera apenas arrays)\n        last_pivot_price_arr = np.full(n, last_pivot_price if last_pivot_price is not None else np.nan)\n        last_pivot_type_arr = np.full(n, None, dtype=object)\n        last_pivot_type_arr[:] = last_pivot_type\n        \n        return {\n            'atr': atr,\n            'zigzag_line': zigzag_line,\n            'pivot_high': pivot_high,\n            'pivot_low': pivot_low,\n            'signal': signal,\n            'trend_ema': trend_ema,\n            'last_pivot_price': last_pivot_price_arr,\n            'last_pivot_type': last_pivot_type_arr,\n        }\n\n    \n    \n    def strategy(self, tick_info, indicators):\n        \"\"\"\n        ESTRAT\u00c9GIA DE EXECU\u00c7\u00c3O\n        \n        REGRAS:\n        1. Stop Loss din\u00e2mico (ATR)\n        2. Trailing stop baseado em piv\u00f4s\n        3. Sinais validados com filtros\n        \"\"\"\n        signal = indicators.get('signal')\n        last_trade = tick_info.get('last_trade')\n        close = tick_info.get('close')\n        current_atr = indicators.get('atr', 0)\n        last_pivot_price = indicators.get('last_pivot_price')\n        last_pivot_type = indicators.get('last_pivot_type')\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # PROTE\u00c7\u00c3O: STOP LOSS DIN\u00c2MICO\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        if isinstance(last_trade, qx.Buy):\n            entry_price = last_trade.price\n            stop_mult = float(self.tune['stop_atr_mult'])\n            \n            # Stop Loss baseado em ATR\n            if current_atr > 0:\n                stop_price = entry_price - (current_atr * stop_mult)\n                \n                if close < stop_price:\n                    return qx.Sell()  # STOP LOSS ACIONADO\n            \n            # Trailing Stop baseado no \u00faltimo piv\u00f4 LOW\n            if last_pivot_type == 'low' and last_pivot_price is not None:\n                # Se romper o \u00faltimo fundo, sair\n                if close < last_pivot_price * 0.995:  # 0.5% de margem\n                    return qx.Sell()  # ESTRUTURA ROMPIDA\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # SINAIS DE ENTRADA/SA\u00cdDA\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        if signal is None:\n            return qx.Hold()\n        \n        # COMPRA: Piv\u00f4 LOW confirmado\n        if signal == 'buy':\n            if last_trade is None or isinstance(last_trade, qx.Sell):\n                return qx.Buy()\n        \n        # VENDA: Piv\u00f4 HIGH confirmado\n        elif signal == 'sell':\n            if isinstance(last_trade, qx.Buy):\n                return qx.Sell()\n        \n        return qx.Hold()\n    \n    \n    def plot(self, data, states, indicators, block):\n        \"\"\"Visualiza\u00e7\u00e3o\"\"\"\n        qx.plot(\n            self.info,\n            data,\n            states,\n            indicators,\n            block,\n            (\n                (\"zigzag_line\", \"ZigZag\", \"cyan\", 0, \"Estrutura\"),\n                (\"pivot_high\", \"Topos\", \"red\", 0, None),\n                (\"pivot_low\", \"Fundos\", \"lime\", 0, None),\n                (\"trend_ema\", \"Tend\u00eancia\", \"yellow\", 0, None),\n                (\"atr\", \"ATR\", \"orange\", 1, \"Volatilidade\"),\n            ),\n        )\n        qx.plotmotion(block)\n    \n    \n    def execution(self, signal, indicators, wallet):\n        \"\"\"Execu\u00e7\u00e3o de ordens\"\"\"\n        if isinstance(signal, qx.Buy):\n            return qx.Buy()\n        elif isinstance(signal, qx.Sell):\n            return qx.Sell()\n        return signal\n    \n    \n    def fitness(self, states, raw_states, asset, currency):\n        \"\"\"M\u00e9tricas de avalia\u00e7\u00e3o\"\"\"\n        return [\n            \"roi\",\n            \"cagr\",\n            \"sortino\",\n            \"sharpe\",\n            \"maximum_drawdown\",\n            \"trade_win_rate\",\n            \"avg_trade_duration\",\n            \"profit_factor\",\n        ], {}\n\n\n# ===========================================================================\n# CONFIGURA\u00c7\u00c3O\n# ===========================================================================\nTIMEFRAME = 900  # 15 minutos\nFEE = 0.1  # 0.1%\n\n\ndef main():\n    \"\"\"Execu\u00e7\u00e3o\"\"\"\n    asset, currency = \"SOL\", \"USDT\"\n    wallet = qx.PaperWallet({asset: 0, currency: 10000}, fee=FEE)\n    \n    data = qx.Data(\n        exchange=\"binance\",\n        asset=asset,\n        currency=currency,\n        begin=\"2025-10-01\",\n        end=int(time.time()),\n        candle_size=TIMEFRAME, \n    )\n    # python strategies/ZigZag_NR.py\n    bot = ZigZag_NR()\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()",
 "BEST ROI TUNE_Fri Jan 23 09:34:23 2026_SOL_USDT_900_Fri Jan 23 09:34:23 2026": {
  "identifier": "BEST ROI TUNE_Fri Jan 23 09:34:23 2026_SOL_USDT_900_Fri Jan 23 09:34:23 2026",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 900,
  "tune": {
   "atr_period": 15.997605720729894,
   "atr_multiplier": 1.878038341908929,
   "pivot_strength": 7,
   "stop_atr_mult": 2.3682966084842874,
   "min_atr_filter": 0.6448201429005964,
   "trend_filter": 42.34221773280832
  },
  "results": {
   "roi": 1.0581330843122274,
   "cagr": 1.6513764974300567,
   "maximum_drawdown": 0.10968785749177531,
   "profit_factor": 2.3288045011747056,
   "trade_win_rate": 0.6956521739130435
  }
 },
 "BEST ROI TUNE_Fri Jan 23 09:49:54 2026_SOL_USDT_900_Fri Jan 23 09:49:54 2026": {
  "identifier": "BEST ROI TUNE_Fri Jan 23 09:49:54 2026_SOL_USDT_900_Fri Jan 23 09:49:54 2026",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 900,
  "tune": {
   "atr_period": 11.721792175092594,
   "atr_multiplier": 2.2711373361819076,
   "pivot_strength": 5,
   "stop_atr_mult": 1.7930275413827328,
   "min_atr_filter": 0.7875063980584454,
   "trend_filter": 1
  },
  "results": {
   "roi": 1.1037095967876973,
   "cagr": 2.0292127135086724,
   "maximum_drawdown": 0.10968785749177513,
   "profit_factor": 1.7371966354716466,
   "trade_win_rate": 0.6296296296296297
  }
 },
 "BEST ROI TUNE_Fri Jan 23 10:04:40 2026_SOL_USDT_300_Fri Jan 23 10:04:40 2026": {
  "identifier": "BEST ROI TUNE_Fri Jan 23 10:04:40 2026_SOL_USDT_300_Fri Jan 23 10:04:40 2026",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "atr_period": 11,
   "atr_multiplier": 2.6432168339127773,
   "pivot_strength": 7,
   "stop_atr_mult": 1.5,
   "min_atr_filter": 0.36736079572137326,
   "trend_filter": 22
  },
  "results": {
   "roi": 1.1169720757083328,
   "cagr": 2.748958196556456,
   "maximum_drawdown": 0.11058962227549342,
   "profit_factor": 4.821176623912966,
   "trade_win_rate": 0.8260869565217391
  }
 },
 "BEST ROI TUNE_Fri Jan 23 10:56:01 2026_SOL_USDT_900_Fri Jan 23 10:56:01 2026": {
  "identifier": "BEST ROI TUNE_Fri Jan 23 10:56:01 2026_SOL_USDT_900_Fri Jan 23 10:56:01 2026",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 900,
  "tune": {
   "atr_period": 21,
   "atr_multiplier": 2.1526839978829146,
   "pivot_strength": 4,
   "stop_atr_mult": 1.5863010858605695,
   "min_atr_filter": 0.692997613071944,
   "trend_filter": 0
  },
  "results": {
   "roi": 1.1824046370712546,
   "cagr": 3.822234242733609,
   "maximum_drawdown": 0.08268496908132522,
   "profit_factor": 2.677403909816588,
   "trade_win_rate": 0.7222222222222222
  }
 },
 "BEST ROI TUNE_Fri Jan 23 11:06:41 2026_SOL_USDT_300_Fri Jan 23 11:06:41 2026": {
  "identifier": "BEST ROI TUNE_Fri Jan 23 11:06:41 2026_SOL_USDT_300_Fri Jan 23 11:06:41 2026",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "atr_period": 13.283358861581075,
   "atr_multiplier": 2.1346490596455743,
   "pivot_strength": 5,
   "stop_atr_mult": 1.8370984507923744,
   "min_atr_filter": 0.4177801098587232,
   "trend_filter": 5
  },
  "results": {
   "roi": 1.1047340016088127,
   "cagr": 2.5922099611637224,
   "maximum_drawdown": 0.11058962227549345,
   "profit_factor": 4.057078443638533,
   "trade_win_rate": 0.8
  }
 }
}