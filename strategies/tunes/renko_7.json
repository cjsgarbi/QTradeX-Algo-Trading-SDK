{
 "source": "\"\"\"\n\u2554\u2550\u2557\u2554\u2566\u2557\u2566\u2550\u2557\u2554\u2550\u2557\u2554\u2566\u2557\u2554\u2550\u2557\u2550\u2557 \u2566\n\u2551\u2550\u256c\u2557\u2551 \u2560\u2566\u255d\u2560\u2550\u2563 \u2551\u2551\u2551\u2563 \u2554\u2569\u2566\u255d\n\u255a\u2550\u255d\u255a\u2569 \u2569\u255a\u2550\u2569 \u2569\u2550\u2569\u255d\u255a\u2550\u255d\u2569 \u255a\u2550\n\nrenko.py\n\nRenko Profissional - Vers\u00e3o Corrigida\n\nCORRE\u00c7\u00d5ES APLICADAS (baseadas em pesquisa com especialistas):\n1. ATR Multiplier aumentado para 2.0-3.0 (evita over-trading)\n2. Filtro de tend\u00eancia com EMA 50 (s\u00f3 opera na dire\u00e7\u00e3o da tend\u00eancia maior)\n3. RSI confirma momentum, n\u00e3o apenas evita extremos\n4. M\u00ednimo de 3 bricks consecutivos para confirmar tend\u00eancia\n5. Stop-loss impl\u00edcito de 2 bricks (revers\u00e3o imediata)\n\nREFER\u00caNCIAS:\n- TradingView: ATR 14 periods com multiplier 1.5-2.5\n- Forex Factory: Stop-loss de 2 Renko bars\n- LuxAlgo: Brick size = 1% do pre\u00e7o ou ATR x 2\n\"\"\"\n\nimport qtradex as qx\nimport numpy as np\n\n\nclass Renko(qx.BaseBot):\n    \"\"\"\n    Estrat\u00e9gia Renko Profissional Corrigida.\n    \n    L\u00d3GICA MELHORADA:\n    1. S\u00f3 opera na dire\u00e7\u00e3o da tend\u00eancia maior (EMA 50)\n    2. Exige confirma\u00e7\u00e3o de bricks consecutivos\n    3. RSI confirma momentum\n    4. ATR maior para evitar ru\u00eddo\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa\u00e7\u00e3o da estrat\u00e9gia.\"\"\"\n        self.timeframe = TIMEFRAME\n        self.fee = FEE\n        self.warmup = 100  # Quantidade de candles para aquecer indicadores\n\n        \n        # ===================================================================\n        # TUNE: Valores padr\u00e3o calibrados (15min Scalp)\n        # Ponto de partida otimizado - bons resultados desde o in\u00edcio\n        # ===================================================================\n        self.tune = {\n            \"atr_len\": 14,             # Meio de 10-24\n            \"atr_mult\": 2.5,           # Meio de 1.5-4.0\n            \"min_bricks\": 3,           # Meio de 2-5\n            \"ema_trend\": 40,           # Meio de 20-60\n            \"rsi_len\": 14,             # Meio de 10-20\n            \"rsi_confirm_bull\": 65,    # Meio de 50-70 (novo range)\n            \"rsi_confirm_bear\": 35,    # Meio de 30-50 (novo range)\n        }\n\n        # ===================================================================\n        # CLAMPS: Cobertura AMPLA para Cripto Vol\u00e1til\n        # Permite ao AION explorar desde scalp r\u00e1pido at\u00e9 swing conservador\n        # ===================================================================\n        self.clamps = {\n            \"atr_len\":          [7, 14, 28, 3],           # 7-28: captura volatilidade curta e longa\n            \"atr_mult\":         [1.0, 2.0, 5.0, 0.5],     # 1.0-5.0: desde agressivo at\u00e9 conservador\n            \"min_bricks\":       [1, 2, 6, 1],             # 1-6: desde r\u00e1pido at\u00e9 muito confirmado\n            \"ema_trend\":        [10, 30, 100, 10],        # 10-100: desde micro-trend at\u00e9 macro-trend\n            \"rsi_len\":          [7, 14, 21, 2],           # 7-21: sensibilidade vari\u00e1vel\n            \"rsi_confirm_bull\": [50, 60, 75, 3],          # 50-75: momentum forte para alta\n            \"rsi_confirm_bear\": [25, 40, 50, 3],          # 25-50: momentum forte para baixa\n        }\n\n    def indicators(self, data):\n        \"\"\"Calcula indicadores t\u00e9cnicos.\"\"\"\n        close = data[\"close\"]\n        high = data[\"high\"]\n        low = data[\"low\"]\n        \n        # ATR para brick size din\u00e2mico\n        atr = qx.ti.atr(high, low, close, int(self.tune[\"atr_len\"]))\n        atr_clean = atr[~np.isnan(atr)]\n        brick_size = np.mean(atr_clean) * self.tune[\"atr_mult\"] if len(atr_clean) > 0 else 100.0\n        \n        # Bricks Renko\n        bricks = self._calculate_renko(close, brick_size)\n        \n        # Contagem de bricks consecutivos\n        consecutive = self._count_consecutive(bricks)\n        \n        # EMA de tend\u00eancia maior (filtro)\n        ema_trend = qx.ti.ema(close, int(self.tune[\"ema_trend\"]))\n        \n        # RSI para confirma\u00e7\u00e3o de momentum\n        rsi = qx.ti.rsi(close, int(self.tune[\"rsi_len\"]))\n        \n        # Tend\u00eancia maior: pre\u00e7o acima ou abaixo da EMA\n        trend_up = close > ema_trend\n        trend_down = close < ema_trend\n        \n        return {\n            \"bricks\": bricks,\n            \"consecutive\": consecutive,\n            \"ema_trend\": ema_trend,\n            \"rsi\": rsi,\n            \"trend_up\": trend_up,\n            \"trend_down\": trend_down,\n            \"brick_size\": np.full_like(close, brick_size),\n        }\n\n    def _calculate_renko(self, close_prices, brick_size):\n        \"\"\"Calcula bricks Renko padr\u00e3o.\"\"\"\n        if len(close_prices) < 2 or brick_size <= 0:\n            return np.zeros_like(close_prices)\n        \n        bricks = np.zeros(len(close_prices))\n        last_price = close_prices[0]\n        \n        for i in range(1, len(close_prices)):\n            price = close_prices[i]\n            diff = price - last_price\n            \n            if diff >= brick_size:\n                count = int(diff / brick_size)\n                bricks[i] = count\n                last_price += count * brick_size\n            elif diff <= -brick_size:\n                count = int(abs(diff) / brick_size)\n                bricks[i] = -count\n                last_price -= count * brick_size\n        \n        return bricks\n\n    def _count_consecutive(self, bricks):\n        \"\"\"Conta bricks consecutivos na mesma dire\u00e7\u00e3o.\"\"\"\n        consecutive = np.zeros_like(bricks)\n        count = 0\n        current_dir = 0\n        \n        for i in range(len(bricks)):\n            if bricks[i] > 0:\n                if current_dir == 1:\n                    count += bricks[i]\n                else:\n                    count = bricks[i]\n                    current_dir = 1\n            elif bricks[i] < 0:\n                if current_dir == -1:\n                    count += abs(bricks[i])\n                else:\n                    count = abs(bricks[i])\n                    current_dir = -1\n            \n            consecutive[i] = count * current_dir\n        \n        return consecutive\n\n    def strategy(self, tick_info, indicators):\n        \"\"\"\n        L\u00f3gica de decis\u00e3o PROFISSIONAL.\n        \n        COMPRA quando:\n        1. Tend\u00eancia maior \u00e9 de ALTA (pre\u00e7o > EMA 50)\n        2. Bricks consecutivos de alta >= min_bricks\n        3. RSI confirma momentum de alta (> 50)\n        \n        VENDA quando:\n        1. Tend\u00eancia maior \u00e9 de BAIXA (pre\u00e7o < EMA 50)\n        2. Bricks consecutivos de baixa >= min_bricks\n        3. RSI confirma momentum de baixa (< 50)\n        \"\"\"\n        consecutive = indicators[\"consecutive\"]\n        rsi = indicators[\"rsi\"]\n        trend_up = indicators[\"trend_up\"]\n        trend_down = indicators[\"trend_down\"]\n        \n        min_bricks = int(self.tune[\"min_bricks\"])\n        rsi_bull = self.tune[\"rsi_confirm_bull\"]\n        rsi_bear = self.tune[\"rsi_confirm_bear\"]\n        \n        # CONDI\u00c7\u00c3O DE COMPRA (3 filtros devem passar)\n        long_signal = (\n            trend_up                    # 1. Tend\u00eancia maior \u00e9 de alta\n            and consecutive >= min_bricks  # 2. Bricks consecutivos confirmam\n            and rsi > rsi_bull          # 3. RSI confirma momentum\n        )\n        \n        # CONDI\u00c7\u00c3O DE VENDA (3 filtros devem passar)\n        short_signal = (\n            trend_down                      # 1. Tend\u00eancia maior \u00e9 de baixa\n            and consecutive <= -min_bricks  # 2. Bricks consecutivos confirmam\n            and rsi < rsi_bear              # 3. RSI confirma momentum\n        )\n        \n        if long_signal and not short_signal:\n            return qx.Buy()\n        elif short_signal and not long_signal:\n            return qx.Sell()\n        \n        return None\n\n    def execution(self, signal, indicators, wallet):\n        \"\"\"Executa ordens no pre\u00e7o de mercado.\"\"\"\n        if isinstance(signal, qx.Buy):\n            return qx.Buy()\n        elif isinstance(signal, qx.Sell):\n            return qx.Sell()\n        return signal\n\n    def plot(self, *args):\n        \"\"\"Define a visualiza\u00e7\u00e3o no gr\u00e1fico.\"\"\"\n        qx.plot(\n            self.info,\n            *args,\n            (\n                (\"ema_trend\", \"EMA Trend\", \"yellow\", 0, \"Renko Pro\"),\n                (\"consecutive\", \"Consecutive Bricks\", \"cyan\", 1, \"Renko\"),\n                (\"rsi\", \"RSI\", \"white\", 2, \"RSI\"),\n            )\n        )\n\n    def fitness(self, states, raw_states, asset, currency):\n        \"\"\"M\u00e9tricas de otimiza\u00e7\u00e3o.\"\"\"\n        return [\n            \"roi_currency\",\n            \"roi\",\n            \"cagr\",\n            \"sortino\",\n            \"maximum_drawdown\",\n            \"trade_win_rate\",\n        ], {}\n\n\n# ===========================================================================\n# CONFIGURA\u00c7\u00c3O GLOBAL\n# ===========================================================================\n# 60=1m, 300=5m, 900=15m, 3600=1h, 14400=4h, 86400=1d\nTIMEFRAME = 300  # Tempo Graf\u00edco\nFEE = 0.1  # 0.1%\n\n\n# ===========================================================================\n# MAIN\n# ===========================================================================\ndef main():\n    \"\"\"Configura e executa a estrat\u00e9gia.\"\"\"\n    import time\n    asset, currency = \"SOL\", \"USDT\"\n    wallet = qx.PaperWallet({asset: 0, currency: 10000}, fee=FEE)\n    \n    data = qx.Data(\n        exchange=\"binance\",\n        asset=asset,\n        currency=currency,\n        begin=\"2025-11-01\",\n        #end=\"2026-01-14\",  # Data fixa (opcional)\n        end=int(time.time()),  # Dados at\u00e9 o segundo atual\n        candle_size=TIMEFRAME, \n    )\n    \n    # python strategies/renko.py\n    # python3 strategies/renko.py\n    bot = Renko()\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()\n",
 "BEST ROI TUNE_Sat Jan 24 13:32:51 2026_SOL_USDT_300_Sat Jan 24 13:32:51 2026": {
  "identifier": "BEST ROI TUNE_Sat Jan 24 13:32:51 2026_SOL_USDT_300_Sat Jan 24 13:32:51 2026",
  "begin_date": "01/11/2025",
  "end_date": "24/01/2026",
  "duration": "2 Meses e 24 Dias",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "atr_len": 17,
   "atr_mult": 3.307710016696272,
   "min_bricks": 5,
   "ema_trend": 29.250594570907115,
   "rsi_len": 20,
   "rsi_confirm_bull": 67.54486553798294,
   "rsi_confirm_bear": 33
  },
  "results": {
   "roi": 1.1386816336474046,
   "roi_currency": 1.1386816336474046,
   "cagr": 3.0431753947003752,
   "maximum_drawdown": 0.07764087770247104,
   "trade_win_rate": 0.8
  }
 },
 "BEST ROI TUNE_Sat Jan 24 13:45:37 2026_SOL_USDT_300_Sat Jan 24 13:45:37 2026": {
  "identifier": "BEST ROI TUNE_Sat Jan 24 13:45:37 2026_SOL_USDT_300_Sat Jan 24 13:45:37 2026",
  "begin_date": "01/11/2025",
  "end_date": "24/01/2026",
  "duration": "2 Meses e 24 Dias",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "atr_len": 7,
   "atr_mult": 2.767746452282025,
   "min_bricks": 6,
   "ema_trend": 99,
   "rsi_len": 17,
   "rsi_confirm_bull": 60,
   "rsi_confirm_bear": 29
  },
  "results": {
   "roi": 1.178448028195847,
   "roi_currency": 1.178448028195847,
   "cagr": 3.673258604333281,
   "maximum_drawdown": 0.07789746584315026,
   "trade_win_rate": 0.8
  }
 }
}