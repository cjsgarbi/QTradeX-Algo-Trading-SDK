{
 "source": "\"\"\"\n\u2554\u2550\u2557\u2554\u2566\u2557\u2566\u2550\u2557\u2554\u2550\u2557\u2554\u2566\u2557\u2554\u2550\u2557\u2550\u2557 \u2566\n\u2551\u2550\u256c\u2557\u2551 \u2560\u2566\u255d\u2560\u2550\u2563 \u2551\u2551\u2551\u2563 \u2554\u2569\u2566\u255d\n\u255a\u2550\u255d\u255a\u2569 \u2569\u255a\u2550\u2569 \u2569\u2550\u2569\u255d\u255a\u2550\u255d\u2569 \u255a\u2550\n\nrenko.py\n\nRenko Profissional - Vers\u00e3o Corrigida\n\nCORRE\u00c7\u00d5ES APLICADAS (baseadas em pesquisa com especialistas):\n1. ATR Multiplier aumentado para 2.0-3.0 (evita over-trading)\n2. Filtro de tend\u00eancia com EMA 50 (s\u00f3 opera na dire\u00e7\u00e3o da tend\u00eancia maior)\n3. RSI confirma momentum, n\u00e3o apenas evita extremos\n4. M\u00ednimo de 3 bricks consecutivos para confirmar tend\u00eancia\n5. Stop-loss impl\u00edcito de 2 bricks (revers\u00e3o imediata)\n\nREFER\u00caNCIAS:\n- TradingView: ATR 14 periods com multiplier 1.5-2.5\n- Forex Factory: Stop-loss de 2 Renko bars\n- LuxAlgo: Brick size = 1% do pre\u00e7o ou ATR x 2\n\"\"\"\n\nimport qtradex as qx\nimport numpy as np\n\n\nclass Renko(qx.BaseBot):\n    \"\"\"\n    Estrat\u00e9gia Renko Profissional Corrigida.\n    \n    L\u00d3GICA MELHORADA:\n    1. S\u00f3 opera na dire\u00e7\u00e3o da tend\u00eancia maior (EMA 50)\n    2. Exige confirma\u00e7\u00e3o de bricks consecutivos\n    3. RSI confirma momentum\n    4. ATR maior para evitar ru\u00eddo\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa\u00e7\u00e3o da estrat\u00e9gia.\"\"\"\n        self.timeframe = TIMEFRAME\n        self.fee = FEE\n        self.warmup = 100  # Quantidade de candles para aquecer indicadores\n\n        \n        # Par\u00e2metros CORRIGIDOS para evitar over-trading\n        self.tune = {\n            \"atr_len\": 14,             # Per\u00edodo do ATR (padr\u00e3o profissional)\n            \"atr_mult\": 2.5,           # AUMENTADO: 2.0-3.0 \u00e9 o padr\u00e3o pro\n            \"min_bricks\": 3,           # AUMENTADO: exige confirma\u00e7\u00e3o forte\n            \"ema_trend\": 50,           # NOVO: filtro de tend\u00eancia maior\n            \"rsi_len\": 14,             # Per\u00edodo RSI\n            \"rsi_confirm_bull\": 50,    # RSI acima de 50 = momentum de alta\n            \"rsi_confirm_bear\": 50,    # RSI abaixo de 50 = momentum de baixa\n        }\n\n        # Limites para otimiza\u00e7\u00e3o - faixas PROFISSIONAIS\n        self.clamps = {\n            \"atr_len\":         [10, 14, 20, 1],\n            \"atr_mult\":        [1.5, 2.5, 4.0, 0.25],  # M\u00ednimo 1.5!\n            \"min_bricks\":      [2, 3, 5, 1],           # M\u00ednimo 2!\n            \"ema_trend\":       [30, 50, 100, 10],\n            \"rsi_len\":         [10, 14, 21, 1],\n            \"rsi_confirm_bull\": [45, 50, 60, 5],\n            \"rsi_confirm_bear\": [40, 50, 55, 5],\n        }\n\n    def indicators(self, data):\n        \"\"\"Calcula indicadores t\u00e9cnicos.\"\"\"\n        close = data[\"close\"]\n        high = data[\"high\"]\n        low = data[\"low\"]\n        \n        # ATR para brick size din\u00e2mico\n        atr = qx.ti.atr(high, low, close, int(self.tune[\"atr_len\"]))\n        atr_clean = atr[~np.isnan(atr)]\n        brick_size = np.mean(atr_clean) * self.tune[\"atr_mult\"] if len(atr_clean) > 0 else 100.0\n        \n        # Bricks Renko\n        bricks = self._calculate_renko(close, brick_size)\n        \n        # Contagem de bricks consecutivos\n        consecutive = self._count_consecutive(bricks)\n        \n        # EMA de tend\u00eancia maior (filtro)\n        ema_trend = qx.ti.ema(close, int(self.tune[\"ema_trend\"]))\n        \n        # RSI para confirma\u00e7\u00e3o de momentum\n        rsi = qx.ti.rsi(close, int(self.tune[\"rsi_len\"]))\n        \n        # Tend\u00eancia maior: pre\u00e7o acima ou abaixo da EMA\n        trend_up = close > ema_trend\n        trend_down = close < ema_trend\n        \n        return {\n            \"bricks\": bricks,\n            \"consecutive\": consecutive,\n            \"ema_trend\": ema_trend,\n            \"rsi\": rsi,\n            \"trend_up\": trend_up,\n            \"trend_down\": trend_down,\n            \"brick_size\": np.full_like(close, brick_size),\n        }\n\n    def _calculate_renko(self, close_prices, brick_size):\n        \"\"\"Calcula bricks Renko padr\u00e3o.\"\"\"\n        if len(close_prices) < 2 or brick_size <= 0:\n            return np.zeros_like(close_prices)\n        \n        bricks = np.zeros(len(close_prices))\n        last_price = close_prices[0]\n        \n        for i in range(1, len(close_prices)):\n            price = close_prices[i]\n            diff = price - last_price\n            \n            if diff >= brick_size:\n                count = int(diff / brick_size)\n                bricks[i] = count\n                last_price += count * brick_size\n            elif diff <= -brick_size:\n                count = int(abs(diff) / brick_size)\n                bricks[i] = -count\n                last_price -= count * brick_size\n        \n        return bricks\n\n    def _count_consecutive(self, bricks):\n        \"\"\"Conta bricks consecutivos na mesma dire\u00e7\u00e3o.\"\"\"\n        consecutive = np.zeros_like(bricks)\n        count = 0\n        current_dir = 0\n        \n        for i in range(len(bricks)):\n            if bricks[i] > 0:\n                if current_dir == 1:\n                    count += bricks[i]\n                else:\n                    count = bricks[i]\n                    current_dir = 1\n            elif bricks[i] < 0:\n                if current_dir == -1:\n                    count += abs(bricks[i])\n                else:\n                    count = abs(bricks[i])\n                    current_dir = -1\n            \n            consecutive[i] = count * current_dir\n        \n        return consecutive\n\n    def strategy(self, tick_info, indicators):\n        \"\"\"\n        L\u00f3gica de decis\u00e3o PROFISSIONAL.\n        \n        COMPRA quando:\n        1. Tend\u00eancia maior \u00e9 de ALTA (pre\u00e7o > EMA 50)\n        2. Bricks consecutivos de alta >= min_bricks\n        3. RSI confirma momentum de alta (> 50)\n        \n        VENDA quando:\n        1. Tend\u00eancia maior \u00e9 de BAIXA (pre\u00e7o < EMA 50)\n        2. Bricks consecutivos de baixa >= min_bricks\n        3. RSI confirma momentum de baixa (< 50)\n        \"\"\"\n        consecutive = indicators[\"consecutive\"]\n        rsi = indicators[\"rsi\"]\n        trend_up = indicators[\"trend_up\"]\n        trend_down = indicators[\"trend_down\"]\n        \n        min_bricks = int(self.tune[\"min_bricks\"])\n        rsi_bull = self.tune[\"rsi_confirm_bull\"]\n        rsi_bear = self.tune[\"rsi_confirm_bear\"]\n        \n        # CONDI\u00c7\u00c3O DE COMPRA (3 filtros devem passar)\n        long_signal = (\n            trend_up                    # 1. Tend\u00eancia maior \u00e9 de alta\n            and consecutive >= min_bricks  # 2. Bricks consecutivos confirmam\n            and rsi > rsi_bull          # 3. RSI confirma momentum\n        )\n        \n        # CONDI\u00c7\u00c3O DE VENDA (3 filtros devem passar)\n        short_signal = (\n            trend_down                      # 1. Tend\u00eancia maior \u00e9 de baixa\n            and consecutive <= -min_bricks  # 2. Bricks consecutivos confirmam\n            and rsi < rsi_bear              # 3. RSI confirma momentum\n        )\n        \n        if long_signal and not short_signal:\n            return qx.Buy()\n        elif short_signal and not long_signal:\n            return qx.Sell()\n        \n        return None\n\n    def execution(self, signal, indicators, wallet):\n        \"\"\"Executa ordens no pre\u00e7o de mercado.\"\"\"\n        if isinstance(signal, qx.Buy):\n            return qx.Buy()\n        elif isinstance(signal, qx.Sell):\n            return qx.Sell()\n        return signal\n\n    def plot(self, *args):\n        \"\"\"Define a visualiza\u00e7\u00e3o no gr\u00e1fico.\"\"\"\n        qx.plot(\n            self.info,\n            *args,\n            (\n                (\"ema_trend\", \"EMA Trend\", \"yellow\", 0, \"Renko Pro\"),\n                (\"consecutive\", \"Consecutive Bricks\", \"cyan\", 1, \"Renko\"),\n                (\"rsi\", \"RSI\", \"white\", 2, \"RSI\"),\n            )\n        )\n\n    def fitness(self, states, raw_states, asset, currency):\n        \"\"\"M\u00e9tricas de otimiza\u00e7\u00e3o.\"\"\"\n        return [\n            \"roi_currency\",\n            \"roi\",\n            \"cagr\",\n            \"sortino\",\n            \"maximum_drawdown\",\n            \"trade_win_rate\",\n        ], {}\n\n\n# ===========================================================================\n# CONFIGURA\u00c7\u00c3O GLOBAL\n# ===========================================================================\n# 60=1m, 300=5m, 900=15m, 3600=1h, 14400=4h, 86400=1d\nTIMEFRAME = 900  # Tempo Graf\u00edco\nFEE = 0.1  # 0.1%\n\n\n# ===========================================================================\n# MAIN\n# ===========================================================================\ndef main():\n    \"\"\"Configura e executa a estrat\u00e9gia.\"\"\"\n    import time\n    asset, currency = \"BTC\", \"USDT\"\n    wallet = qx.PaperWallet({asset: 0, currency: 10000}, fee=FEE)\n    \n    data = qx.Data(\n        exchange=\"binance\",\n        asset=asset,\n        currency=currency,\n        begin=\"2025-06-01\",\n        #end=\"2026-01-14\",  # Data fixa (opcional)\n        end=int(time.time()),  # Dados at\u00e9 o segundo atual\n        candle_size=TIMEFRAME, \n    )\n    \n    # python strategies/renko.py\n    bot = Renko()\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()\n",
 "BEST ROI TUNE_Thu Jan 22 16:42:27 2026_BTC_USDT_900_Thu Jan 22 16:42:27 2026": {
  "identifier": "BEST ROI TUNE_Thu Jan 22 16:42:27 2026_BTC_USDT_900_Thu Jan 22 16:42:27 2026",
  "asset": "BTC",
  "currency": "USDT",
  "timeframe": 900,
  "tune": {
   "atr_len": 14.57667149450823,
   "atr_mult": 1.8901246839569579,
   "min_bricks": 5,
   "ema_trend": 30,
   "rsi_len": 12,
   "rsi_confirm_bull": 53.86348633765693,
   "rsi_confirm_bear": 49.50220293308973
  },
  "results": {
   "roi": 1.080249184568633,
   "roi_currency": 1.080249184568633,
   "cagr": 0.26654586536085634,
   "maximum_drawdown": 0.1467933666449659,
   "trade_win_rate": 0.35714285714285715
  }
 },
 "BEST ROI TUNE_Thu Jan 22 20:22:56 2026_BTC_USDT_900_Thu Jan 22 20:22:56 2026": {
  "identifier": "BEST ROI TUNE_Thu Jan 22 20:22:56 2026_BTC_USDT_900_Thu Jan 22 20:22:56 2026",
  "asset": "BTC",
  "currency": "USDT",
  "timeframe": 900,
  "tune": {
   "atr_len": 14.57667149450823,
   "atr_mult": 1.8901246839569579,
   "min_bricks": 5,
   "ema_trend": 30,
   "rsi_len": 12,
   "rsi_confirm_bull": 53.86348633765693,
   "rsi_confirm_bear": 49.50220293308973
  },
  "results": {
   "roi": 1.077804095392021,
   "roi_currency": 1.077804095392021,
   "cagr": 0.264128927556188,
   "maximum_drawdown": 0.1467933666449659,
   "trade_win_rate": 0.35714285714285715
  }
 }
}