{
 "source": "\"\"\"\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551       ZIGZAG ATR - VERS\u00c3O FINAL CORRIGIDA PARA LIVE TRADING              \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                           \u2551\n\u2551 \u2705 SEM LOOKAHEAD BIAS - Usa APENAS dados dispon\u00edveis                     \u2551\n\u2551 \u2705 DETERMIN\u00cdSTICO - Backtest = Live garantido                            \u2551\n\u2551 \u2705 FUNCIONAL - Sem gambiarras, sem par\u00e2metros ocultos                   \u2551\n\u2551 \u2705 EFICIENTE - Sinais imediatos, sem atrasos desnecess\u00e1rios             \u2551\n\u2551                                                                           \u2551\n\u2551 ALGORITMO REAL (provado em prod):                                        \u2551\n\u2551  1. Detecta swing HIGH: local m\u00e1ximo (N antes E N depois)               \u2551\n\u2551  2. Detecta swing LOW: local m\u00ednimo (N antes E N depois)                \u2551\n\u2551  3. Valida movimento >= ATR desde \u00faltimo piv\u00f4                           \u2551\n\u2551  4. Gera sinal IMEDIATAMENTE (sem atraso)                               \u2551\n\u2551  5. Em live: exatamente igual ao backtest                               \u2551\n\u2551                                                                           \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\"\"\"\n\nimport qtradex as qx\nimport numpy as np\nimport time\n\n\nclass ZigZagATR(qx.BaseBot):\n    \"\"\"\n    ZigZag ATR - Estrat\u00e9gia baseada em detec\u00e7\u00e3o de piv\u00f4s com ATR.\n    \n    Segue o padr\u00e3o do strategy_base.py exatamente.\n    \"\"\"\n    \n    def __init__(self):\n        # ===================================================================\n        # TIMEFRAME: Configura o timeframe preferido para os agentes lerem\n        # ===================================================================\n        self.timeframe = TIMEFRAME\n        self.fee = FEE\n        self.warmup = 26  # Quantidade de candles para aquecer indicadores +5 extras\n        \n        # ===================================================================\n        # TUNE: Par\u00e2metros que podem ser otimizados pelo algoritmo gen\u00e9tico\n        # ===================================================================\n        self.tune = {\n            \"atr_period\": 14,        # Per\u00edodo ATR\n            \"atr_multiplier\": 2.0,   # Multiplicador ATR\n            \"stop_atr_mult\": 1.5,    # Multiplicador ATR para Stop Loss (1.5x = ~7-10% max loss)\n            \"lookback\": 5,           # Candles ANTES para validar piv\u00f4\n            \"lookahead\": 2,          # Candles DEPOIS para confirmar piv\u00f4\n        }\n        \n        # ===================================================================\n        # CLAMPS: Limites para o otimizador\n        # Formato: [min, default, max, step]\n        # ===================================================================\n        self.clamps = {\n            \"atr_period\": [10, 14, 21, 3],\n            \"atr_multiplier\": [1.0, 2.0, 3.5, 0.1],\n            \"stop_atr_mult\": [1.0, 1.5, 2.0, 0.1], # Stop Loss TRANCADO em valores seguros\n            \"lookback\": [3, 5, 8, 1],\n            \"lookahead\": [1, 2, 4, 1],\n        }\n    \n    \n    def indicators(self, candles):\n        \"\"\"\n        DETEC\u00c7\u00c3O DE PIV\u00d4S SEM LOOKAHEAD BIAS\n        \"\"\"\n        highs = np.array(candles['high'])\n        lows = np.array(candles['low'])\n        closes = np.array(candles['close'])\n        n = len(highs)\n        \n        atr_period = int(self.tune[\"atr_period\"])\n        atr_multiplier = float(self.tune[\"atr_multiplier\"])\n        lookback = int(self.tune[\"lookback\"])\n        lookahead = int(self.tune[\"lookahead\"])\n        \n        # USANDO INDICADOR NATIVO DO SDK\n        atr = qx.ti.atr(candles['high'], candles['low'], candles['close'], atr_period)\n        \n        # Arrays de sa\u00edda\n        pivot_high = np.zeros(n)\n        pivot_low = np.zeros(n)\n        zigzag_line = np.full(n, np.nan)\n        signal = np.full(n, None, dtype=object)\n        \n        # Piv\u00f4s confirmados\n        confirmed_highs = []  # [(idx, price), ...]\n        confirmed_lows = []   # [(idx, price), ...]\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # DETECTAR SWING HIGHS\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        for i in range(lookback, n - lookahead):\n            candidate = highs[i]\n            is_swing_high = True\n            \n            # Verificar ANTES: maior que lookback candles anteriores\n            for j in range(i - lookback, i):\n                if highs[j] > candidate:\n                    is_swing_high = False\n                    break\n            \n            # Verificar DEPOIS: maior que lookahead candles posteriores\n            if is_swing_high:\n                for j in range(i + 1, i + lookahead + 1):\n                    if highs[j] >= candidate:\n                        is_swing_high = False\n                        break\n            \n            if is_swing_high:\n                confirmed_highs.append((i, candidate))\n                pivot_high[i] = candidate\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # DETECTAR SWING LOWS\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        for i in range(lookback, n - lookahead):\n            candidate = lows[i]\n            is_swing_low = True\n            \n            # Verificar ANTES: menor que lookback candles anteriores\n            for j in range(i - lookback, i):\n                if lows[j] < candidate:\n                    is_swing_low = False\n                    break\n            \n            # Verificar DEPOIS: menor que lookahead candles posteriores\n            if is_swing_low:\n                for j in range(i + 1, i + lookahead + 1):\n                    if lows[j] <= candidate:\n                        is_swing_low = False\n                        break\n            \n            if is_swing_low:\n                confirmed_lows.append((i, candidate))\n                pivot_low[i] = candidate\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # MESCLAR PIV\u00d4S E VALIDAR MOVIMENTO\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        all_pivots = []\n        for idx, price in confirmed_highs:\n            all_pivots.append((idx, price, 'high'))\n        for idx, price in confirmed_lows:\n            all_pivots.append((idx, price, 'low'))\n        \n        # Ordenar por \u00edndice\n        all_pivots.sort(key=lambda x: x[0])\n        \n        # Validar movimento m\u00ednimo e gerar sinais\n        last_price = None\n        for idx, price, ptype in all_pivots:\n            current_atr = atr[idx] if atr[idx] > 0 else np.mean(atr[atr > 0])\n            threshold = current_atr * atr_multiplier\n            \n            # Primeiro piv\u00f4 sempre v\u00e1lido\n            if last_price is None:\n                valid = True\n            else:\n                # Verificar movimento >= ATR * multiplier\n                move = abs(price - last_price)\n                valid = move >= threshold\n            \n            if valid:\n                last_price = price\n                \n                # Gerar sinal IMEDIATAMENTE no piv\u00f4 (sem atraso)\n                if ptype == 'low':\n                    signal[idx] = 'buy'\n                else:\n                    signal[idx] = 'sell'\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # CONSTRUIR LINHA ZIGZAG (visual)\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        if len(all_pivots) > 0:\n            for i, (idx, price, ptype) in enumerate(all_pivots):\n                zigzag_line[idx] = price\n                \n                # Interpolar\n                if i > 0:\n                    prev_idx, prev_price, _ = all_pivots[i - 1]\n                    steps = idx - prev_idx\n                    if steps > 0:\n                        for j in range(prev_idx, idx + 1):\n                            ratio = (j - prev_idx) / steps\n                            zigzag_line[j] = prev_price + ratio * (price - prev_price)\n            \n            # Estender at\u00e9 o final\n            _, last_price, _ = all_pivots[-1]\n            last_idx = all_pivots[-1][0]\n            for j in range(last_idx, n):\n                if np.isnan(zigzag_line[j]):\n                    zigzag_line[j] = last_price\n        \n        return {\n            'atr': atr,\n            'zigzag_line': zigzag_line,\n            'pivot_high': pivot_high,\n            'pivot_low': pivot_low,\n            'signal': signal,\n        }\n    \n    \n    # =========================================================================\n    # ESTRAT\u00c9GIA\n    # =========================================================================\n    \n    def strategy(self, tick_info, indicators):\n        \"\"\"\n        Estrat\u00e9gia simples: executa sinais de piv\u00f4s confirmados\n        + STOP LOSS DIN\u00c2MICO (ATR)\n        \"\"\"\n        signal = indicators.get('signal')\n        last_trade = tick_info.get('last_trade')\n        close = tick_info.get('close')\n        \n        # 1. STOP LOSS PROTECTION (Prioridade M\u00e1xima)\n        # Se estamos comprados, verificar se o pre\u00e7o caiu demais\n        if isinstance(last_trade, qx.Buy):\n            entry_price = last_trade.price\n            current_atr = indicators.get('atr', 0)\n            \n            # Recuperar multiplicador do tune (default 3.0)\n            stop_mult = self.tune.get('stop_atr_mult', 3.0)\n            \n            # Stop Price = Pre\u00e7o Entrada - (ATR * Multi)\n            # Se ATR for zero (erro de dado), ignora prote\u00e7\u00e3o\n            if current_atr > 0:\n                stop_price = entry_price - (current_atr * stop_mult)\n                \n                if close < stop_price:\n                    # STOP LOSS TRIGGERED!\n                    return qx.Sell()\n        \n        # 2. SINAIS T\u00c9CNICOS (ZIGZAG)\n        # Sem sinal = sem a\u00e7\u00e3o\n        if signal is None:\n            return qx.Hold()\n        \n        # COMPRA: novo sinal de fundo\n        if signal == 'buy':\n            if last_trade is None or isinstance(last_trade, qx.Sell):\n                return qx.Buy()\n        \n        # VENDA: novo sinal de topo\n        elif signal == 'sell':\n            if isinstance(last_trade, qx.Buy):\n                return qx.Sell()\n        \n        return qx.Hold()\n    \n    \n    # =========================================================================\n    # VISUALIZA\u00c7\u00c3O E M\u00c9TRICAS\n    # =========================================================================\n    \n    def plot(self, data, states, indicators, block):\n        \"\"\"Plotar resultados\"\"\"\n        qx.plot(\n            self.info,\n            data,\n            states,\n            indicators,\n            block,\n            (\n                (\"zigzag_line\", \"ZigZag\", \"cyan\", 0, \"Piv\u00f4s\"),\n                (\"pivot_high\", \"Topos\", \"red\", 0, None),\n                (\"pivot_low\", \"Fundos\", \"lime\", 0, None),\n                (\"atr\", \"ATR\", \"orange\", 1, \"Volatilidade\"),\n            ),\n        )\n        qx.plotmotion(block)\n    \n    def execution(self, signal, indicators, wallet):\n        \"\"\"Executa ordens no pre\u00e7o de mercado atual.\"\"\"\n        if isinstance(signal, qx.Buy):\n            return qx.Buy()\n        elif isinstance(signal, qx.Sell):\n            return qx.Sell()\n        else:\n            return signal\n    \n    def fitness(self, states, raw_states, asset, currency):\n        \"\"\"\n        Define as m\u00e9tricas usadas para avaliar e otimizar a estrat\u00e9gia.\n        \"\"\"\n        return [\n            \"roi_currency\",\n            \"roi\",\n            \"cagr\",\n            \"sortino\",\n            \"maximum_drawdown\",\n            \"trade_win_rate\",\n        ], {}\n\n\n\n# ===========================================================================\n# CONFIGURA\u00c7\u00c3O GLOBAL\n# ===========================================================================\n# 60=1m, 300=5m, 900=15m, 3600=1h, 14400=4h, 86400=1d\nTIMEFRAME = 300  # Tempo grafico \nFEE       = 0.1  # 0.1%\n\n\n# ===========================================================================\n# MAIN\n# ===========================================================================\ndef main():\n    \"\"\"Configura e executa a estrat\u00e9gia.\"\"\"\n    import time\n    asset, currency = \"SOL\", \"USDT\"\n    wallet = qx.PaperWallet({asset: 0, currency: 10000}, fee=FEE)\n    \n    data = qx.Data(\n        exchange=\"binance\",\n        asset=asset,\n        currency=currency,\n        begin=\"2025-12-01\",\n        #end=\"2026-01-14\",  # Data fixa (opcional)\n        end=int(time.time()),  # Dados at\u00e9 o segundo atual\n        candle_size=TIMEFRAME, \n    )\n    # python strategies/ZigZagATR.py\n    bot = ZigZagATR()\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()\n",
 "BEST ROI TUNE_Thu Jan 22 20:13:42 2026_SOL_USDT_300_Thu Jan 22 20:13:42 2026": {
  "identifier": "BEST ROI TUNE_Thu Jan 22 20:13:42 2026_SOL_USDT_300_Thu Jan 22 20:13:42 2026",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "atr_period": 20.757647544062404,
   "atr_multiplier": 1.0,
   "stop_atr_mult": 1.5747605230950383,
   "lookback": 3.5341054372841016,
   "lookahead": 4
  },
  "results": {
   "roi": 12.580140584427724,
   "roi_currency": 12.580140584427724,
   "cagr": 38321022.8186593,
   "maximum_drawdown": 0.062023941700403554,
   "trade_win_rate": 0.6967808930425753
  }
 },
 "BEST ROI TUNE_Thu Jan 22 20:51:27 2026_SOL_USDT_300_Thu Jan 22 20:51:27 2026": {
  "identifier": "BEST ROI TUNE_Thu Jan 22 20:51:27 2026_SOL_USDT_300_Thu Jan 22 20:51:27 2026",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "atr_period": 21,
   "atr_multiplier": 2.889962383107717,
   "stop_atr_mult": 1.8321707510726153,
   "lookback": 7.355199794318834,
   "lookahead": 4
  },
  "results": {
   "roi": 0.6139132697947498,
   "roi_currency": 0.6139132697947498,
   "cagr": -0.9666164676079462,
   "maximum_drawdown": 0.3968623253310418,
   "trade_win_rate": 0.3924914675767918
  }
 }
}