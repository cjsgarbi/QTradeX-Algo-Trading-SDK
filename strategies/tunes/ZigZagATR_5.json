{
 "source": "\"\"\"\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551       ZIGZAG ATR - VERS\u00c3O FINAL CORRIGIDA PARA LIVE TRADING              \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                           \u2551\n\u2551 \u2705 SEM LOOKAHEAD BIAS - Usa APENAS dados dispon\u00edveis                     \u2551\n\u2551 \u2705 DETERMIN\u00cdSTICO - Backtest = Live garantido                            \u2551\n\u2551 \u2705 FUNCIONAL - Sem gambiarras, sem par\u00e2metros ocultos                   \u2551\n\u2551 \u2705 EFICIENTE - Sinais imediatos, sem atrasos desnecess\u00e1rios             \u2551\n\u2551                                                                           \u2551\n\u2551 ALGORITMO REAL (provado em prod):                                        \u2551\n\u2551  1. Detecta swing HIGH: local m\u00e1ximo (N antes E N depois)               \u2551\n\u2551  2. Detecta swing LOW: local m\u00ednimo (N antes E N depois)                \u2551\n\u2551  3. Valida movimento >= ATR desde \u00faltimo piv\u00f4                           \u2551\n\u2551  4. Gera sinal IMEDIATAMENTE (sem atraso)                               \u2551\n\u2551  5. Em live: exatamente igual ao backtest                               \u2551\n\u2551                                                                           \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\"\"\"\n\nimport qtradex as qx\nimport numpy as np\nimport time\n\n\nclass ZigZagATR(qx.BaseBot):\n    \"\"\"\n    ZigZag ATR - Estrat\u00e9gia baseada em detec\u00e7\u00e3o de piv\u00f4s com ATR.\n    \n    Segue o padr\u00e3o do strategy_base.py exatamente.\n    \"\"\"\n    \n    def __init__(self):\n        # ===================================================================\n        # TIMEFRAME: Configura o timeframe preferido para os agentes lerem\n        # ===================================================================\n        self.timeframe = TIMEFRAME\n        self.fee = FEE\n        self.warmup = 26  # Quantidade de candles para aquecer indicadores +5 extras\n        \n        # ===================================================================\n        # TUNE: Valores padr\u00e3o calibrados (Ponto de partida otimizado)\n        # ===================================================================\n        self.tune = {\n            \"atr_period\": 14,        # Meio de 7-28\n            \"atr_multiplier\": 2.5,   # Meio de 1.0-5.0\n            \"stop_atr_mult\": 2.0,    # Meio de 1.0-4.0\n            \"lookback\": 5,           # Meio de 1-10\n            \"lookahead\": 2,          # Meio de 1-5 (Menor delay)\n        }\n        \n        # ===================================================================\n        # CLAMPS: Cobertura AMPLA para Cripto Vol\u00e1til\n        # Permite ao AION explorar desde condi\u00e7\u00f5es calmas at\u00e9 explosivas\n        # ===================================================================\n        self.clamps = {\n            \"atr_period\":       [7, 14, 28, 3],           # 7-28: volatilidade curta e longa\n            \"atr_multiplier\":    [1.0, 2.5, 5.0, 0.5],     # 1.0-5.0: agressivo a conservador\n            \"stop_atr_mult\":    [1.0, 2.0, 4.0, 0.5],     # 1.0-4.0: prote\u00e7\u00e3o flex\u00edvel\n            \"lookback\":         [1, 5, 10, 1],            # 1-10: detec\u00e7\u00e3o de pico r\u00e1pida ou lenta\n            \"lookahead\":        [1, 2, 5, 1],             # 1-5: confirma\u00e7\u00e3o de piv\u00f4\n        }\n    \n    \n    def indicators(self, candles):\n        \"\"\"\n        DETEC\u00c7\u00c3O DE PIV\u00d4S SEM LOOKAHEAD BIAS\n        \"\"\"\n        highs = np.array(candles['high'])\n        lows = np.array(candles['low'])\n        closes = np.array(candles['close'])\n        n = len(highs)\n        \n        atr_period = int(self.tune[\"atr_period\"])\n        atr_multiplier = float(self.tune[\"atr_multiplier\"])\n        lookback = int(self.tune[\"lookback\"])\n        lookahead = int(self.tune[\"lookahead\"])\n        \n        # USANDO INDICADOR NATIVO DO SDK\n        atr = qx.ti.atr(candles['high'], candles['low'], candles['close'], atr_period)\n        \n        # Arrays de sa\u00edda\n        pivot_high = np.full(n, np.nan)\n        pivot_low = np.full(n, np.nan)\n        zigzag_line = np.full(n, np.nan)\n        signal = np.full(n, None, dtype=object)\n        \n        # Piv\u00f4s confirmados\n        confirmed_highs = []  # [(idx, price), ...]\n        confirmed_lows = []   # [(idx, price), ...]\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # DETECTAR SWING HIGHS\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        for i in range(lookback, n - lookahead):\n            candidate = highs[i]\n            is_swing_high = True\n            \n            # Verificar ANTES: maior que lookback candles anteriores\n            for j in range(i - lookback, i):\n                if highs[j] > candidate:\n                    is_swing_high = False\n                    break\n            \n            # Verificar DEPOIS: maior que lookahead candles posteriores\n            if is_swing_high:\n                for j in range(i + 1, i + lookahead + 1):\n                    if highs[j] >= candidate:\n                        is_swing_high = False\n                        break\n            \n            if is_swing_high:\n                confirmed_highs.append((i, candidate))\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # DETECTAR SWING LOWS\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        for i in range(lookback, n - lookahead):\n            candidate = lows[i]\n            is_swing_low = True\n            \n            # Verificar ANTES: menor que lookback candles anteriores\n            for j in range(i - lookback, i):\n                if lows[j] < candidate:\n                    is_swing_low = False\n                    break\n            \n            # Verificar DEPOIS: menor que lookahead candles posteriores\n            if is_swing_low:\n                for j in range(i + 1, i + lookahead + 1):\n                    if lows[j] <= candidate:\n                        is_swing_low = False\n                        break\n            \n            if is_swing_low:\n                confirmed_lows.append((i, candidate))\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # MESCLAR PIV\u00d4S E VALIDAR MOVIMENTO\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        all_pivots = []\n        for idx, price in confirmed_highs:\n            all_pivots.append((idx, price, 'high'))\n        for idx, price in confirmed_lows:\n            all_pivots.append((idx, price, 'low'))\n        \n        # Ordenar por \u00edndice\n        all_pivots.sort(key=lambda x: x[0])\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # DETEC\u00c7\u00c3O DE ESTRUTURA (HH, HL, LH, LL)\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        valid_pivots = []\n        last_p_price = None\n        for idx, price, ptype in all_pivots:\n            c_atr = atr[idx] if atr[idx] > 0 else np.mean(atr[atr > 0])\n            if last_p_price is None or abs(price - last_p_price) >= (c_atr * atr_multiplier):\n                valid_pivots.append((idx, price, ptype))\n                last_p_price = price\n        \n        # Arrays para os \u00faltimos n\u00edveis de estrutura\n        struct_h = np.full(n, np.nan)\n        struct_l = np.full(n, np.nan)\n        \n        h_history = []\n        l_history = []\n        \n        for idx, price, ptype in valid_pivots:\n            exec_idx = idx + lookahead\n            if exec_idx >= n: continue\n            \n            if ptype == 'high':\n                h_history.append(price)\n            else:\n                l_history.append(price)\n            \n            # Registrar n\u00edveis de resist\u00eancia/suporte\n            if h_history: struct_h[exec_idx:] = h_history[-1]\n            if l_history: struct_l[exec_idx:] = l_history[-1]\n\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # CONSTRUIR LINHA ZIGZAG E PIV\u00d4S (Visual)\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        for idx, price, ptype in valid_pivots:\n            if ptype == 'high': pivot_high[idx] = price\n            else: pivot_low[idx] = price\n            zigzag_line[idx] = price\n\n        # Interpolar linha ZigZag\n        last_v_idx = None\n        for i in range(n):\n            if not np.isnan(zigzag_line[i]):\n                if last_v_idx is not None:\n                    p1, p2 = zigzag_line[last_v_idx], zigzag_line[i]\n                    dist = i - last_v_idx\n                    for j in range(last_v_idx + 1, i):\n                        zigzag_line[j] = p1 + (j - last_v_idx) * (p2 - p1) / dist\n                last_v_idx = i\n\n        return {\n            'atr': atr,\n            'zigzag_line': zigzag_line,\n            'pivot_high': pivot_high,\n            'pivot_low': pivot_low,\n            'signal': signal,\n            'struct_h': struct_h, # Resist\u00eancia (Topo anterior)\n            'struct_l': struct_l, # Suporte (Fundo anterior)\n        }\n    \n    \n    # =========================================================================\n    # ESTRAT\u00c9GIA\n    # =========================================================================\n    \n    def strategy(self, tick_info, indicators):\n        \"\"\"\n        Estrat\u00e9gia PRO: Market Structure + BOS (Break of Structure)\n        \n        Gatilho: Rompimento do Topo/Fundo anterior ap\u00f3s confirma\u00e7\u00e3o de piv\u00f4.\n        Sem repainting e com m\u00e1xima assertividade institucional.\n        \"\"\"\n        close = tick_info.get('close')\n        last_trade = tick_info.get('last_trade')\n        \n        # Extrair n\u00edveis de estrutura confirmados (No-Repaint)\n        # struct_h/l j\u00e1 levam em considera\u00e7\u00e3o o lookahead\n        res = indicators.get('struct_h', np.nan)\n        sup = indicators.get('struct_l', np.nan)\n        \n        # Modo live: pega o \u00faltimo valor\n        if isinstance(res, (np.ndarray, list)): res = res[-1]\n        if isinstance(sup, (np.ndarray, list)): sup = sup[-1]\n        \n        atr_array = indicators.get('atr')\n        current_atr = atr_array[-1] if isinstance(atr_array, (np.ndarray, list)) else atr_array\n\n        # 1. GEST\u00c3O DE RISCO (STOP LOSS T\u00c9CNICO)\n        if isinstance(last_trade, qx.Buy):\n            # Stop Loss no Fundo Anterior confirmado (Suporte T\u00e9cnico)\n            # Se n\u00e3o houver sup, usa ATR como fallback\n            stop_price = sup if not np.isnan(sup) else (last_trade.price - current_atr * 2)\n            if close < stop_price: return qx.Sell()\n            \n        elif isinstance(last_trade, qx.Sell):\n            # Stop Loss no Topo Anterior confirmado (Resist\u00eancia T\u00e9cnica)\n            stop_price = res if not np.isnan(res) else (last_trade.price + current_atr * 2)\n            if close > stop_price: return qx.Buy()\n\n        # 2. GATILHOS DE ENTRADA (BOS - Break of Structure)\n        # S\u00f3 compramos se o pre\u00e7o romper a resist\u00eancia anterior (Res) ap\u00f3s um fundo confirmado\n        if not np.isnan(res) and close > res:\n            if last_trade is None or isinstance(last_trade, qx.Sell):\n                return qx.Buy()\n                \n        # S\u00f3 vendemos se o pre\u00e7o romper o suporte anterior (Sup) ap\u00f3s um topo confirmado\n        elif not np.isnan(sup) and close < sup:\n            if last_trade is None or isinstance(last_trade, qx.Buy):\n                return qx.Sell()\n        \n        return qx.Hold()\n    \n    \n    # =========================================================================\n    # VISUALIZA\u00c7\u00c3O E M\u00c9TRICAS\n    # =========================================================================\n    \n    def plot(self, data, states, indicators, block):\n        \"\"\"Visualiza\u00e7\u00e3o limpa e profissional seguindo padr\u00e3o do reposit\u00f3rio.\"\"\"\n        qx.plot(\n            self.info,\n            data,\n            states,\n            indicators,\n            block,\n            (\n                (\"zigzag_line\", \"ZigZag\", \"cyan\", 0, \"ZigZag Pro\"),\n                (\"struct_h\", \"Resist\u00eancia\", \"red\", 0, None),\n                (\"struct_l\", \"Suporte\", \"lime\", 0, None),\n                (\"pivot_high\", \"\u25b2 Topo\", \"white\", 0, None),\n                (\"pivot_low\", \"\u25bc Fundo\", \"white\", 0, None),\n                (\"atr\", \"ATR\", \"orange\", 1, \"Volatilidade\"),\n            ),\n        )\n        qx.plotmotion(block)\n    \n    def execution(self, signal, indicators, wallet):\n        \"\"\"Executa ordens no pre\u00e7o de mercado atual.\"\"\"\n        if isinstance(signal, qx.Buy):\n            return qx.Buy()\n        elif isinstance(signal, qx.Sell):\n            return qx.Sell()\n        else:\n            return signal\n    \n    def fitness(self, states, raw_states, asset, currency):\n        \"\"\"\n        Define as m\u00e9tricas usadas para avaliar e otimizar a estrat\u00e9gia.\n        \"\"\"\n        return [\n            \"roi_currency\",\n            \"roi\",\n            \"cagr\",\n            \"sortino\",\n            \"maximum_drawdown\",\n            \"trade_win_rate\",\n        ], {}\n\n\n\n# ===========================================================================\n# CONFIGURA\u00c7\u00c3O GLOBAL\n# ===========================================================================\n# 60=1m, 300=5m, 900=15m, 3600=1h, 14400=4h, 86400=1d\nTIMEFRAME = 300  # Tempo grafico \nFEE       = 0.1  # 0.1%\n\n\n# ===========================================================================\n# MAIN\n# ===========================================================================\ndef main():\n    \"\"\"Configura e executa a estrat\u00e9gia.\"\"\"\n    import time\n    asset, currency = \"SOL\", \"USDT\"\n    wallet = qx.PaperWallet({asset: 0, currency: 10000}, fee=FEE)\n    \n    data = qx.Data(\n        exchange=\"binance\",\n        asset=asset,\n        currency=currency,\n        begin=\"2025-11-01\",\n        #end=\"2026-01-14\",  # Data fixa (opcional)\n        end=int(time.time()),  # Dados at\u00e9 o segundo atual\n        candle_size=TIMEFRAME, \n    )\n    # python strategies/ZigZagATR.py\n    bot = ZigZagATR()\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()\n",
 "BEST ROI TUNE_Sat Jan 24 18:23:06 2026_SOL_USDT_300_Sat Jan 24 18:23:06 2026": {
  "identifier": "BEST ROI TUNE_Sat Jan 24 18:23:06 2026_SOL_USDT_300_Sat Jan 24 18:23:06 2026",
  "begin_date": "01/12/2025",
  "end_date": "24/01/2026",
  "duration": "1 M\u00eas e 24 Dias",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "atr_period": 7,
   "atr_multiplier": 4.860756403727104,
   "stop_atr_mult": 1.0,
   "lookback": 7,
   "lookahead": 1
  },
  "results": {
   "roi": 1.1071324434924283,
   "roi_currency": 1.1071324434924283,
   "cagr": 0.9717595894641042,
   "maximum_drawdown": 0.1210727753030563,
   "trade_win_rate": 0.46296296296296297
  }
 }
}