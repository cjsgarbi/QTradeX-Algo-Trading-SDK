{
 "source": "\"\"\"\n\u2554\u2550\u2557\u2554\u2566\u2557\u2566\u2550\u2557\u2554\u2550\u2557\u2554\u2566\u2557\u2554\u2550\u2557\u2550\u2557 \u2566\n\u2551\u2550\u256c\u2557\u2551 \u2560\u2566\u255d\u2560\u2550\u2563 \u2551\u2551\u2551\u2563 \u2554\u2569\u2566\u255d\n\u255a\u2550\u255d\u255a\u2569 \u2569\u255a\u2550\u2569 \u2569\u2550\u2569\u255d\u255a\u2550\u255d\u2569 \u255a\u2550\n\nrenko_scalp.py\n\nRenko Scalping - Alta Frequ\u00eancia (6+ trades/dia)\n\nOBJETIVO: Lucros pequenos mas consistentes em alta frequ\u00eancia\n- Timeframe: 5 minutos\n- ATR peque\u00f1o para capturar movimentos menores\n- Sem filtro de tend\u00eancia (permite trades em qualquer dire\u00e7\u00e3o)\n- Confirma\u00e7\u00e3o r\u00e1pida (1-2 bricks)\n\"\"\"\n\nimport qtradex as qx\nimport numpy as np\nfrom datetime import datetime\nimport time\n\nclass RenkoScalp(qx.BaseBot):\n    \"\"\"\n    Estrat\u00e9gia Renko Scalping.\n    \n    L\u00d3GICA:\n    1. Bricks pequenos para capturar micro-movimentos\n    2. Entrada r\u00e1pida (1-2 bricks de confirma\u00e7\u00e3o)\n    3. RSI para filtrar apenas os extremos perigosos\n    4. Sem filtro de tend\u00eancia (opera em qualquer dire\u00e7\u00e3o)\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa\u00e7\u00e3o da estrat\u00e9gia.\"\"\"\n        self.timeframe = TIMEFRAME\n        self.fee = FEE\n        self.warmup = 90  # Quantidade de candles para aquecer indicadores\n        \n        # Par\u00e2metros para SCALPING (alta frequ\u00eancia)\n        self.tune = {\n            \"atr_len\": 14,                # Mais est\u00e1vel\n            \"atr_mult\": 3.0,              # Brick > Fees (0.2%)\n            \"min_bricks\": 2,              # Confirma\u00e7\u00e3o robusta\n            \"rsi_len\": 14,                # Padr\u00e3o\n            \"rsi_oversold\": 30,           \n            \"rsi_overbought\": 70,         \n        }\n\n        # Limites para otimiza\u00e7\u00e3o - faixas SCALPING VI\u00c1VEL\n        self.clamps = {\n            \"atr_len\":        [10, 20, 30, 1],\n            \"atr_mult\":       [2.0, 4.0, 6.0, 0.2],   # Brick Grande!\n            \"min_bricks\":     [2, 3, 5, 1],           # Evitar ru\u00eddo\n            \"rsi_len\":        [7, 14, 21, 1],\n            \"rsi_oversold\":   [20, 30, 40, 1],        \n            \"rsi_overbought\": [60, 70, 80, 1],        \n        }\n\n    def indicators(self, data):\n        \"\"\"Calcula indicadores t\u00e9cnicos.\"\"\"\n        close = data[\"close\"]\n        high = data[\"high\"]\n        low = data[\"low\"]\n        \n        # ATR para brick size din\u00e2mico\n        atr = qx.ti.atr(high, low, close, int(self.tune[\"atr_len\"]))\n        atr_clean = atr[~np.isnan(atr)]\n        brick_size = np.mean(atr_clean) * self.tune[\"atr_mult\"] if len(atr_clean) > 0 else 50.0\n        \n        # Bricks Renko\n        bricks = self._calculate_renko(close, brick_size)\n        \n        # Contagem de bricks consecutivos\n        consecutive = self._count_consecutive(bricks)\n        \n        # RSI r\u00e1pido\n        rsi = qx.ti.rsi(close, int(self.tune[\"rsi_len\"]))\n        \n        return {\n            \"bricks\": bricks,\n            \"consecutive\": consecutive,\n            \"rsi\": rsi,\n            \"brick_size\": np.full_like(close, brick_size),\n        }\n\n    def _calculate_renko(self, close_prices, brick_size):\n        \"\"\"Calcula bricks Renko verdadeiros.\"\"\"\n        if len(close_prices) < 2 or brick_size <= 0:\n            return np.zeros_like(close_prices)\n        \n        bricks = np.zeros(len(close_prices))\n        last_price = close_prices[0]\n        \n        for i in range(1, len(close_prices)):\n            price = close_prices[i]\n            diff = price - last_price\n            \n            if diff >= brick_size:\n                count = int(diff / brick_size)\n                bricks[i] = count\n                last_price += count * brick_size\n            elif diff <= -brick_size:\n                count = int(abs(diff) / brick_size)\n                bricks[i] = -count\n                last_price -= count * brick_size\n        \n        return bricks\n\n    def _count_consecutive(self, bricks):\n        \"\"\"Conta bricks consecutivos.\"\"\"\n        consecutive = np.zeros_like(bricks)\n        count = 0\n        current_dir = 0\n        \n        for i in range(len(bricks)):\n            if bricks[i] > 0:\n                if current_dir == 1:\n                    count += bricks[i]\n                else:\n                    count = bricks[i]\n                    current_dir = 1\n            elif bricks[i] < 0:\n                if current_dir == -1:\n                    count += abs(bricks[i])\n                else:\n                    count = abs(bricks[i])\n                    current_dir = -1\n            \n            consecutive[i] = count * current_dir\n        \n        return consecutive\n\n    def strategy(self, tick_info, indicators):\n        \"\"\"\n        L\u00f3gica de decis\u00e3o SCALPING.\n        \n        COMPRA: Bricks de alta >= min_bricks E RSI n\u00e3o sobrecomprado\n        VENDA: Bricks de baixa >= min_bricks E RSI n\u00e3o sobrevendido\n        \"\"\"\n        consecutive = indicators[\"consecutive\"]\n        rsi = indicators[\"rsi\"]\n        \n        min_bricks = int(self.tune[\"min_bricks\"])\n        oversold = self.tune[\"rsi_oversold\"]\n        overbought = self.tune[\"rsi_overbought\"]\n        \n        # COMPRA: Momentum de alta confirmado\n        long_signal = (\n            consecutive >= min_bricks\n            and rsi < overbought  # N\u00e3o comprar topo\n        )\n        \n        # VENDA: Momentum de baixa confirmado\n        short_signal = (\n            consecutive <= -min_bricks\n            and rsi > oversold  # N\u00e3o vender fundo\n        )\n        \n        if long_signal and not short_signal:\n            return qx.Buy()\n        elif short_signal and not long_signal:\n            return qx.Sell()\n        \n        return None\n\n    def execution(self, signal, indicators, wallet):\n        \"\"\"Executa ordens no pre\u00e7o de mercado.\"\"\"\n        if isinstance(signal, qx.Buy):\n            return qx.Buy()\n        elif isinstance(signal, qx.Sell):\n            return qx.Sell()\n        return signal\n\n    def plot(self, *args):\n        \"\"\"Define a visualiza\u00e7\u00e3o no gr\u00e1fico.\"\"\"\n        qx.plot(\n            self.info,\n            *args,\n            (\n                (\"consecutive\", \"Consecutive Bricks\", \"cyan\", 1, \"Renko Scalp\"),\n                (\"rsi\", \"RSI\", \"white\", 2, \"RSI\"),\n            )\n        )\n\n    def fitness(self, states, raw_states, asset, currency):\n        \"\"\"M\u00e9tricas de otimiza\u00e7\u00e3o.\"\"\"\n        return [\n            \"roi_currency\",\n            \"roi\",\n            \"cagr\",\n            \"sortino\",\n            \"maximum_drawdown\",\n            \"trade_win_rate\",\n        ], {}\n\n\n# ===========================================================================\n# CONFIGURA\u00c7\u00c3O GLOBAL - SCALPING\n# ===========================================================================\nTIMEFRAME = 300  # 5 minutos (Solitado pelo usu\u00e1rio)\nFEE = 0.1  # 0.1%\n\n# ===========================================================================\n# MAIN\n# ===========================================================================\ndef main():\n    \"\"\"Configura e executa a estrat\u00e9gia.\"\"\"\n\n    asset, currency = \"BTC\", \"USDT\"\n    # Come\u00e7ar com USDT \u00e9 melhor para estrat\u00e9gias de compra/venda, pois evita a taxa inicial de venda de todo o BTC\n    wallet = qx.PaperWallet({asset: 0, currency: 10000}, fee=FEE)  \n    \n    data = qx.Data(\n        exchange=\"binance\",\n        asset=asset,\n        currency=currency,\n        begin=\"2025-12-01\",  # Per\u00edodo unificado para resgatar os 95% de ROI\n        #end=\"2026-01-14\",  # Data fixa (opcional)\n        end=int(time.time()), # Dados at\u00e9 o segundo atual (Unix Timestamp)\n        candle_size=TIMEFRAME,\n    )\n\n    \n    # python strategies/renko_scalp.py\n    bot = RenkoScalp()\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()\n\n",
 "BEST ROI TUNE_Thu Jan 22 16:50:58 2026_BTC_USDT_300_Thu Jan 22 16:50:58 2026": {
  "identifier": "BEST ROI TUNE_Thu Jan 22 16:50:58 2026_BTC_USDT_300_Thu Jan 22 16:50:58 2026",
  "asset": "BTC",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "atr_len": 24.116324306145692,
   "atr_mult": 2.0,
   "min_bricks": 5,
   "rsi_len": 18,
   "rsi_oversold": 40,
   "rsi_overbought": 63.581927765194166
  },
  "results": {
   "roi": 1.1249578243519542,
   "roi_currency": 1.1249578243519542,
   "cagr": 1.0037803221924744,
   "maximum_drawdown": 0.05849567673043498,
   "trade_win_rate": 0.5555555555555556
  }
 }
}