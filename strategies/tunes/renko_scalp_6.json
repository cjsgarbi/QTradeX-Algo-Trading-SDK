{
 "source": "\"\"\"\n\u2554\u2550\u2557\u2554\u2566\u2557\u2566\u2550\u2557\u2554\u2550\u2557\u2554\u2566\u2557\u2554\u2550\u2557\u2550\u2557 \u2566\n\u2551\u2550\u256c\u2557\u2551 \u2560\u2566\u255d\u2560\u2550\u2563 \u2551\u2551\u2551\u2563 \u2554\u2569\u2566\u255d\n\u255a\u2550\u255d\u255a\u2569 \u2569\u255a\u2550\u2569 \u2569\u2550\u2569\u255d\u255a\u2550\u255d\u2569 \u255a\u2550\n\nrenko_scalp.py\n\nRenko Scalping - Alta Frequ\u00eancia (6+ trades/dia)\n\nOBJETIVO: Lucros pequenos mas consistentes em alta frequ\u00eancia\n- Timeframe: 5 minutos\n- ATR peque\u00f1o para capturar movimentos menores\n- Sem filtro de tend\u00eancia (permite trades em qualquer dire\u00e7\u00e3o)\n- Confirma\u00e7\u00e3o r\u00e1pida (1-2 bricks)\n\"\"\"\n\nimport qtradex as qx\nimport numpy as np\nfrom datetime import datetime\nimport time\n\nclass RenkoScalp(qx.BaseBot):\n    \"\"\"\n    Estrat\u00e9gia Renko Scalping.\n    \n    L\u00d3GICA:\n    1. Bricks pequenos para capturar micro-movimentos\n    2. Entrada r\u00e1pida (1-2 bricks de confirma\u00e7\u00e3o)\n    3. RSI para filtrar apenas os extremos perigosos\n    4. Sem filtro de tend\u00eancia (opera em qualquer dire\u00e7\u00e3o)\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa\u00e7\u00e3o da estrat\u00e9gia.\"\"\"\n        self.timeframe = TIMEFRAME\n        self.fee = FEE\n        self.warmup = 90  # Quantidade de candles para aquecer indicadores\n        \n        # ===================================================================\n        # TUNE: Valores padr\u00e3o calibrados (15min Scalp)\n        # Ponto de partida otimizado - bons resultados desde o in\u00edcio\n        # ===================================================================\n        self.tune = {\n            \"atr_len\": 16,                # Meio de 10-24\n            \"atr_mult\": 3.5,              # Meio de 2.0-5.0\n            \"min_bricks\": 3,              # Meio de 2-4\n            \"rsi_len\": 14,                # Meio de 10-20\n            \"rsi_oversold\": 30,           # Meio de 20-40\n            \"rsi_overbought\": 70,         # Meio de 60-80\n        }\n\n        # ===================================================================\n        # CLAMPS: Cobertura TOTAL para Scalp/Swing (at\u00e9 1 dia)\n        # Eficiente mas sem perder oportunidades\n        # ===================================================================\n        self.clamps = {\n            \"atr_len\":        [10, 16, 24, 2],         # step 2 = 8 op\u00e7\u00f5es\n            \"atr_mult\":       [2.0, 3.5, 5.0, 0.5],    # step 0.5 = 7 op\u00e7\u00f5es\n            \"min_bricks\":     [2, 3, 4, 1],            # 3 op\u00e7\u00f5es\n            \"rsi_len\":        [10, 14, 20, 2],         # step 2 = 6 op\u00e7\u00f5es\n            \"rsi_oversold\":   [20, 30, 45, 3],         # step 3 = cripto vol\u00e1til\n            \"rsi_overbought\": [55, 70, 80, 3],         # step 3 = cripto vol\u00e1til\n        }\n\n    def indicators(self, data):\n        \"\"\"Calcula indicadores t\u00e9cnicos.\"\"\"\n        close = data[\"close\"]\n        high = data[\"high\"]\n        low = data[\"low\"]\n        \n        # ATR para brick size din\u00e2mico\n        atr = qx.ti.atr(high, low, close, int(self.tune[\"atr_len\"]))\n        atr_clean = atr[~np.isnan(atr)]\n        brick_size = np.mean(atr_clean) * self.tune[\"atr_mult\"] if len(atr_clean) > 0 else 50.0\n        \n        # Bricks Renko\n        bricks = self._calculate_renko(close, brick_size)\n        \n        # Contagem de bricks consecutivos\n        consecutive = self._count_consecutive(bricks)\n        \n        # RSI r\u00e1pido\n        rsi = qx.ti.rsi(close, int(self.tune[\"rsi_len\"]))\n        \n        return {\n            \"bricks\": bricks,\n            \"consecutive\": consecutive,\n            \"rsi\": rsi,\n            \"brick_size\": np.full_like(close, brick_size),\n        }\n\n    def _calculate_renko(self, close_prices, brick_size):\n        \"\"\"Calcula bricks Renko verdadeiros.\"\"\"\n        if len(close_prices) < 2 or brick_size <= 0:\n            return np.zeros_like(close_prices)\n        \n        bricks = np.zeros(len(close_prices))\n        last_price = close_prices[0]\n        \n        for i in range(1, len(close_prices)):\n            price = close_prices[i]\n            diff = price - last_price\n            \n            if diff >= brick_size:\n                count = int(diff / brick_size)\n                bricks[i] = count\n                last_price += count * brick_size\n            elif diff <= -brick_size:\n                count = int(abs(diff) / brick_size)\n                bricks[i] = -count\n                last_price -= count * brick_size\n        \n        return bricks\n\n    def _count_consecutive(self, bricks):\n        \"\"\"Conta bricks consecutivos.\"\"\"\n        consecutive = np.zeros_like(bricks)\n        count = 0\n        current_dir = 0\n        \n        for i in range(len(bricks)):\n            if bricks[i] > 0:\n                if current_dir == 1:\n                    count += bricks[i]\n                else:\n                    count = bricks[i]\n                    current_dir = 1\n            elif bricks[i] < 0:\n                if current_dir == -1:\n                    count += abs(bricks[i])\n                else:\n                    count = abs(bricks[i])\n                    current_dir = -1\n            \n            consecutive[i] = count * current_dir\n        \n        return consecutive\n\n    def strategy(self, tick_info, indicators):\n        \"\"\"\n        L\u00f3gica de decis\u00e3o SCALPING.\n        \n        COMPRA: Bricks de alta >= min_bricks E RSI n\u00e3o sobrecomprado\n        VENDA: Bricks de baixa >= min_bricks E RSI n\u00e3o sobrevendido\n        \"\"\"\n        # Extrair valores - funciona para arrays (papertrade) e escalares (backtest)\n        def get_last(val):\n            if hasattr(val, \"__len__\") and not isinstance(val, str):\n                return val[-1] if len(val) > 0 else 0\n            return val\n\n        consecutive = get_last(indicators.get(\"consecutive\", 0))\n        rsi = get_last(indicators.get(\"rsi\", 50))\n        \n        min_bricks = int(self.tune[\"min_bricks\"])\n        oversold = self.tune[\"rsi_oversold\"]\n        overbought = self.tune[\"rsi_overbought\"]\n        \n        # COMPRA: Momentum de alta confirmado\n        long_signal = (\n            consecutive >= min_bricks\n            and rsi < overbought  # N\u00e3o comprar topo\n        )\n        \n        # VENDA: Momentum de baixa confirmado\n        short_signal = (\n            consecutive <= -min_bricks\n            and rsi > oversold  # N\u00e3o vender fundo\n        )\n        \n        if long_signal and not short_signal:\n            return qx.Buy()\n        elif short_signal and not long_signal:\n            return qx.Sell()\n        \n        return qx.Hold()\n\n    def execution(self, signal, indicators, wallet):\n        \"\"\"Executa ordens no pre\u00e7o de mercado.\"\"\"\n        if isinstance(signal, qx.Buy):\n            return qx.Buy()\n        elif isinstance(signal, qx.Sell):\n            return qx.Sell()\n        return signal\n\n    def plot(self, *args):\n        \"\"\"Define a visualiza\u00e7\u00e3o no gr\u00e1fico.\"\"\"\n        qx.plot(\n            self.info,\n            *args,\n            (\n                (\"consecutive\", \"Consecutive Bricks\", \"cyan\", 1, \"Renko Scalp\"),\n                (\"rsi\", \"RSI\", \"white\", 2, \"RSI\"),\n            )\n        )\n\n    def fitness(self, states, raw_states, asset, currency):\n        \"\"\"M\u00e9tricas de otimiza\u00e7\u00e3o.\"\"\"\n        return [\n            \"roi_currency\",\n            \"roi\",\n            \"cagr\",\n            \"sortino\",\n            \"maximum_drawdown\",\n            \"trade_win_rate\",\n        ], {}\n\n\n# ===========================================================================\n# CONFIGURA\u00c7\u00c3O GLOBAL - SCALPING\n# ===========================================================================\n# 60=1m, 300=5m, 900=15m, 3600=1h, 14400=4h, 86400=1d\nTIMEFRAME = 300  # 5 minutos (Solitado pelo usu\u00e1rio)\nFEE = 0.1  # 0.1%\n\n# ===========================================================================\n# MAIN\n# ===========================================================================\ndef main():\n    \"\"\"Configura e executa a estrat\u00e9gia.\"\"\"\n\n    asset, currency = \"BTC\", \"USDT\"\n    # Come\u00e7ar com USDT \u00e9 melhor para estrat\u00e9gias de compra/venda, pois evita a taxa inicial de venda de todo o BTC\n    wallet = qx.PaperWallet({asset: 0, currency: 10000}, fee=FEE)  \n    \n    data = qx.Data(\n        exchange=\"binance\",\n        asset=asset,\n        currency=currency,\n        begin=\"2025-10-01\",  # Per\u00edodo unificado para resgatar os 95% de ROI\n        #end=\"2026-01-14\",  # Data fixa (opcional)\n        end=int(time.time()), # Dados at\u00e9 o segundo atual (Unix Timestamp)\n        candle_size=TIMEFRAME,\n    )\n\n    \n    # python strategies/renko_scalp.py\n    bot = RenkoScalp()\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()\n\n",
 "BEST ROI TUNE_Sat Jan 24 14:15:41 2026_BTC_USDT_300_Sat Jan 24 14:15:41 2026": {
  "identifier": "BEST ROI TUNE_Sat Jan 24 14:15:41 2026_BTC_USDT_300_Sat Jan 24 14:15:41 2026",
  "begin_date": "01/10/2025",
  "end_date": "24/01/2026",
  "duration": "3 Meses e 25 Dias",
  "asset": "BTC",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "atr_len": 22.715631332108345,
   "atr_mult": 2.0,
   "min_bricks": 4,
   "rsi_len": 17,
   "rsi_oversold": 41,
   "rsi_overbought": 55
  },
  "results": {
   "roi": 1.0760012404300734,
   "roi_currency": 1.0760012404300734,
   "cagr": 0.8595085069411645,
   "maximum_drawdown": 0.08281266679446984,
   "trade_win_rate": 0.5405405405405406
  }
 },
 "BEST ROI TUNE_Sat Jan 24 16:18:40 2026_SOL_USDT_300_Sat Jan 24 16:18:40 2026": {
  "identifier": "BEST ROI TUNE_Sat Jan 24 16:18:40 2026_SOL_USDT_300_Sat Jan 24 16:18:40 2026",
  "begin_date": "01/10/2025",
  "end_date": "24/01/2026",
  "duration": "3 Meses e 25 Dias",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "atr_len": 17,
   "atr_mult": 2.3754784487459597,
   "min_bricks": 4,
   "rsi_len": 13,
   "rsi_oversold": 39,
   "rsi_overbought": 60
  },
  "results": {
   "roi": 1.1305214747517898,
   "roi_currency": 1.1305214747517898,
   "cagr": 2.2249200978882393,
   "maximum_drawdown": 0.12448755630797051,
   "trade_win_rate": 0.5263157894736842
  }
 }
}