{
 "source": "\"\"\"\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551           ZIGZAG PIVOTS - BASEADO EM FREQTRADE/TECHNICAL                 \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551 Implementa\u00e7\u00e3o REAL extra\u00edda de: freqtrade/technical/pivots_points.py     \u2551\n\u2551 Padr\u00e3o VALIDADO e FUNCIONAL usado por traders profissionais              \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\"\"\"\n\nimport qtradex as qx\nimport numpy as np\nimport pandas as pd\n\n\nclass ZigZagPivots(qx.BaseBot):\n    \"\"\"\n    ZigZag baseado em Pivot Points - IMPLEMENTA\u00c7\u00c3O FREQTRADE\n    \n    FONTE: https://github.com/freqtrade/technical/blob/main/technical/pivots_points.py\n    \n    CONCEITO:\n    - Usa rolling windows para calcular Pivot Points\n    - Pivot = (High + Low + Close) / 3\n    - Resist\u00eancia/Suporte baseados em f\u00f3rmulas TradingView\n    - ZigZag alterna entre R1 (topo) e S1 (fundo)\n    \"\"\"\n    \n    \n    def __init__(self):\n        # ===================================================================\n        # TIMEFRAME: Configura o timeframe preferido para os agentes lerem\n        # ===================================================================\n        self.timeframe = TIMEFRAME\n        self.fee = FEE\n        \n        \n        # Estado da estrat\u00e9gia\n        self.last_zigzag_high = None\n        self.last_zigzag_low = None\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # CLAMPS - Par\u00e2metros otimiz\u00e1veis\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        self.clamps = {\n            'zigzag_threshold': [0.1, 0.3, 0.8, 0.05],  # % m\u00ednimo para scalping\n            'stop_loss_pct': [0.2, 0.4, 0.8, 0.05],     # Stop loss scalping\n            'take_profit_pct': [0.3, 0.6, 1.2, 0.1],    # Take profit scalping\n            'trend_period': [10, 20, 50, 5],            # EMA r\u00e1pida\n            'rsi_period': [7, 14, 21, 1],\n            'rsi_oversold': [20, 30, 40, 5],\n            'rsi_overbought': [60, 70, 80, 5],\n        }\n        \n        self.tune = {\n            'zigzag_threshold': 0.3,    # 0.3% para scalping 5m (era 1%)\n            'stop_loss_pct': 0.4,       # Stop apertado 0.4%\n            'take_profit_pct': 0.6,     # Take profit 0.6% (ratio 1.5:1)\n            'trend_period': 20,         # EMA mais r\u00e1pida (era 50)\n            'rsi_period': 14,\n            'rsi_oversold': 30,\n            'rsi_overbought': 70,\n        }\n    \n    def calculate_zigzag(self, dataframe, threshold_pct):\n        \"\"\"\n        ZigZag NON-REPAINTING - Marca piv\u00f4s no momento da CONFIRMA\u00c7\u00c3O (sem lookahead)\n        \n        threshold_pct: varia\u00e7\u00e3o m\u00ednima em % para considerar revers\u00e3o\n        \n        IMPORTANTE: O piv\u00f4 s\u00f3 \u00e9 marcado no candle ATUAL quando a revers\u00e3o \u00e9 confirmada.\n        Isso introduz um atraso (lag), mas \u00e9 100% honesto para backtest e live trading.\n        \"\"\"\n        highs = dataframe['high'].values\n        lows = dataframe['low'].values\n        closes = dataframe['close'].values\n        n = len(dataframe)\n        \n        # Arrays de sa\u00edda\n        zigzag_high = np.full(n, np.nan)  # \u00daltimo topo confirmado\n        zigzag_low = np.full(n, np.nan)   # \u00daltimo fundo confirmado\n        \n        # Estado\n        last_confirmed_high = highs[0]\n        last_confirmed_low = lows[0]\n        pending_high = highs[0]\n        pending_low = lows[0]\n        direction = 0  # 0=indefinido, 1=buscando topo, -1=buscando fundo\n        \n        for i in range(1, n):\n            current_high = highs[i]\n            current_low = lows[i]\n            current_close = closes[i]\n            \n            if direction == 0:\n                # Inicializa\u00e7\u00e3o: detectar primeira dire\u00e7\u00e3o\n                if current_close > pending_high * (1 + threshold_pct / 100):\n                    direction = 1  # Subindo, buscando topo\n                    pending_high = current_high\n                elif current_close < pending_low * (1 - threshold_pct / 100):\n                    direction = -1  # Descendo, buscando fundo\n                    pending_low = current_low\n                    \n            elif direction == 1:  # Buscando TOPO\n                # Atualizar topo pendente se fizer nova m\u00e1xima\n                if current_high > pending_high:\n                    pending_high = current_high\n                \n                # CONFIRMA\u00c7\u00c3O: Pre\u00e7o recuou threshold% do topo pendente\n                if current_close < pending_high * (1 - threshold_pct / 100):\n                    # CONFIRMA TOPO AGORA (no candle atual, N\u00c3O no passado!)\n                    last_confirmed_high = pending_high\n                    direction = -1  # Agora buscando fundo\n                    pending_low = current_low\n                    \n            elif direction == -1:  # Buscando FUNDO\n                # Atualizar fundo pendente se fizer nova m\u00ednima\n                if current_low < pending_low:\n                    pending_low = current_low\n                \n                # CONFIRMA\u00c7\u00c3O: Pre\u00e7o subiu threshold% do fundo pendente\n                if current_close > pending_low * (1 + threshold_pct / 100):\n                    # CONFIRMA FUNDO AGORA (no candle atual, N\u00c3O no passado!)\n                    last_confirmed_low = pending_low\n                    direction = 1  # Agora buscando topo\n                    pending_high = current_high\n            \n            # Salvar estado da estrutura no candle atual\n            zigzag_high[i] = last_confirmed_high\n            zigzag_low[i] = last_confirmed_low\n        \n        # Usar zigzag_low como linha principal (sinal de fundo = compra)\n        return zigzag_low, zigzag_high\n    \n    def indicators(self, candles):\n        \"\"\"\n        Calcula ZigZag REAL + EMA de tend\u00eancia\n        \"\"\"\n        # Converter dict de arrays para DataFrame\n        df = pd.DataFrame({\n            'high': candles['high'],\n            'low': candles['low'],\n            'close': candles['close'],\n        })\n        \n        threshold = float(self.tune[\"zigzag_threshold\"])\n        trend_period = int(self.tune[\"trend_period\"])\n        rsi_period = int(self.tune[\"rsi_period\"])\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # ZIGZAG NON-REPAINTING - Topos e fundos confirmados\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        zigzag_low, zigzag_high = self.calculate_zigzag(df, threshold)\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # EMA DE TEND\u00caNCIA - Filtro para n\u00e3o operar contra tend\u00eancia\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        ema_trend = df['close'].ewm(span=trend_period, adjust=False).mean().values\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # RSI - Confirma revers\u00e3o (sobrevendido = fundo real)\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        delta = df['close'].diff()\n        gain = (delta.where(delta > 0, 0)).rolling(window=rsi_period).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=rsi_period).mean()\n        rs = gain / loss\n        rsi = 100 - (100 / (1 + rs))\n        rsi_values = rsi.values\n        \n        return {\n            'zigzag_line': zigzag_low,        # \u00daltimo fundo confirmado (Suporte)\n            'zigzag_high': zigzag_high,       # \u00daltimo topo confirmado (Resist\u00eancia)\n            'ema_trend': ema_trend,           # EMA para filtro de tend\u00eancia\n            'rsi': rsi_values,                # RSI para confirmar revers\u00e3o\n            'close': df['close'].values,      # Pre\u00e7o de fechamento\n        }\n    \n    def strategy(self, tick_info, indicators):\n        \"\"\"\n        Estrat\u00e9gia ZigZag REAL com filtro de tend\u00eancia + stop/take profit\n        \n        L\u00d3GICA:\n        1. Detecta FUNDO no ZigZag (revers\u00e3o de baixa para alta)\n        2. Confirma com EMA (pre\u00e7o > EMA = tend\u00eancia de alta)\n        3. COMPRA no fundo confirmado\n        4. VENDA com stop loss OU take profit\n        \"\"\"\n        # Extrair valores\n        def get_value(val, idx=-1):\n            if isinstance(val, (np.ndarray, list)):\n                if len(val) >= abs(idx):\n                    return val[idx]\n                return np.nan\n            return val\n        \n        zigzag_line = get_value(indicators.get('zigzag_line'))\n        ema_trend = get_value(indicators.get('ema_trend'))\n        rsi = get_value(indicators.get('rsi'))\n        close_prices = indicators.get('close')\n        current_price = tick_info.get('close')\n        last_trade = tick_info.get('last_trade')\n        \n        # Valida\u00e7\u00f5es\n        if current_price is None or close_prices is None:\n            return qx.Hold()\n        \n        if np.isnan(zigzag_line) or np.isnan(ema_trend) or np.isnan(rsi):\n            return qx.Hold()\n        \n        # Calcular se pre\u00e7o cruzou zigzag (simples e eficaz)\n        prev_close = get_value(close_prices, -2)\n        has_history = isinstance(close_prices, (list, np.ndarray)) and len(close_prices) > 1\n        prev_zigzag = get_value(indicators.get('zigzag_line'), -2) if has_history else zigzag_line\n        \n        crossed_up = prev_close <= prev_zigzag and current_price > zigzag_line\n        crossed_down = prev_close >= prev_zigzag and current_price < zigzag_line\n        \n        # Par\u00e2metros\n        stop_loss_pct = float(self.tune[\"stop_loss_pct\"])\n        take_profit_pct = float(self.tune[\"take_profit_pct\"])\n        rsi_oversold = float(self.tune[\"rsi_oversold\"])\n        rsi_overbought = float(self.tune[\"rsi_overbought\"])\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # SEM POSI\u00c7\u00c3O - Buscar entrada\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        if last_trade is None or isinstance(last_trade, qx.Sell):\n            # COMPRA: Pre\u00e7o cruzou ACIMA do \u00faltimo fundo confirmado (Suporte)\n            # Filtro: S\u00f3 compra se tend\u00eancia \u00e9 de alta (pre\u00e7o > EMA)\n            if crossed_up and current_price > ema_trend:\n                return qx.Buy()\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # COM POSI\u00c7\u00c3O - Gerenciar sa\u00edda\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        elif isinstance(last_trade, qx.Buy):\n            entry_price = last_trade.price\n            \n            # STOP LOSS\n            stop_price = entry_price * (1 - stop_loss_pct / 100)\n            if current_price <= stop_price:\n                return qx.Sell()\n            \n            # TAKE PROFIT\n            take_price = entry_price * (1 + take_profit_pct / 100)\n            if current_price >= take_price:\n                return qx.Sell()\n            \n            # SA\u00cdDA ANTECIPADA: RSI sobrecomprado OU cruzamento de baixa\n            if rsi >= rsi_overbought or crossed_down:\n                return qx.Sell()\n        \n        return qx.Hold()\n    \n    def plot(self, *args):\n        \"\"\"Plotagem dos indicadores\"\"\"\n        qx.plot(\n            self.info,\n            *args,\n            (\n                (\"zigzag_line\", \"Suporte (Fundo)\", \"lime\", 0, \"Main\"),\n                (\"zigzag_high\", \"Resist\u00eancia (Topo)\", \"red\", 0, \"Main\"),\n                (\"ema_trend\", \"EMA Trend\", \"orange\", 0, \"Main\"),\n            ),\n        )\n    \n\n\n    def fitness(self, states, raw_states, asset, currency):\n        \"\"\"M\u00e9tricas de performance para otimiza\u00e7\u00e3o\"\"\"\n        return [\n            \"roi_assets\",\n            \"roi_currency\",\n            \"roi\",\n            \"cagr\",\n            \"sortino\", \n            \"maximum_drawdown\",\n            \"trade_win_rate\",\n        ], {}\n\n\n# ===========================================================================\n# CONFIGURA\u00c7\u00c3O GLOBAL\n# ===========================================================================\n# 60=1m, 300=5m, 900=15m, 3600=1h, 14400=4h, 86400=1d\nTIMEFRAME = 3600  # 15 minutos (900 segundos)\nFEE = 0.1  # 0.1%\n\n\n# ===========================================================================\n# MAIN\n# ===========================================================================\ndef main():\n    \"\"\"Configura e executa a estrat\u00e9gia.\"\"\"\n    import time\n    asset, currency = \"SOL\", \"USDT\"\n    wallet = qx.PaperWallet({asset: 0, currency: 10000}, fee=FEE)\n    \n    data = qx.Data(\n        exchange=\"binance\",\n        asset=asset,\n        currency=currency,\n        begin=\"2025-06-01\",\n        #end=\"2026-01-14\",  # Data fixa (opcional)\n        end=int(time.time()),  # Dados at\u00e9 o segundo atual\n        candle_size=TIMEFRAME, \n    )\n    # python strategies/ZigZagPivots.py\n    bot = ZigZagPivots()\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()\n\n    \n",
 "BEST ROI TUNE_Sat Jan 17 19:00:10 2026_SOL_USDT_3600_Sat Jan 17 19:00:10 2026": {
  "identifier": "BEST ROI TUNE_Sat Jan 17 19:00:10 2026_SOL_USDT_3600_Sat Jan 17 19:00:10 2026",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 3600,
  "tune": {
   "zigzag_threshold": 0.3,
   "stop_loss_pct": 0.4,
   "take_profit_pct": 0.6,
   "trend_period": 20,
   "rsi_period": 14,
   "rsi_oversold": 30,
   "rsi_overbought": 70
  },
  "results": {
   "roi_assets": 1.0,
   "roi_currency": 1.09203515327659,
   "roi": 1.0,
   "cagr": 0.07241264747022869,
   "maximum_drawdown": 0.3171631157311865,
   "trade_win_rate": 0
  }
 }
}