{
 "source": "\"\"\"\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551           ZIGZAG PIVOTS - BASEADO EM FREQTRADE/TECHNICAL                 \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551 Implementa\u00e7\u00e3o REAL extra\u00edda de: freqtrade/technical/pivots_points.py     \u2551\n\u2551 Padr\u00e3o VALIDADO e FUNCIONAL usado por traders profissionais              \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\"\"\"\n\nimport qtradex as qx\nimport numpy as np\nimport pandas as pd\n\n\nclass ZigZagPivots(qx.BaseBot):\n    \"\"\"\n    ZigZag baseado em Pivot Points - IMPLEMENTA\u00c7\u00c3O FREQTRADE\n    \n    FONTE: https://github.com/freqtrade/technical/blob/main/technical/pivots_points.py\n    \n    CONCEITO:\n    - Usa rolling windows para calcular Pivot Points\n    - Pivot = (High + Low + Close) / 3\n    - Resist\u00eancia/Suporte baseados em f\u00f3rmulas TradingView\n    - ZigZag alterna entre R1 (topo) e S1 (fundo)\n    \"\"\"\n    \n    \n    def __init__(self):\n        # ===================================================================\n        # TIMEFRAME: Configura o timeframe preferido para os agentes lerem\n        # ===================================================================\n        self.timeframe = TIMEFRAME\n        self.fee = FEE\n        \n        \n        # Estado da estrat\u00e9gia\n        self.last_zigzag_high = None\n        self.last_zigzag_low = None\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # CLAMPS - Par\u00e2metros otimiz\u00e1veis\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        self.clamps = {\n            'zigzag_threshold': [0.1, 0.3, 0.8, 0.05],  # % m\u00ednimo para scalping\n            'stop_loss_pct': [0.2, 0.4, 0.8, 0.05],     # Stop loss scalping\n            'take_profit_pct': [0.3, 0.6, 1.2, 0.1],    # Take profit scalping\n            'trend_period': [10, 20, 50, 5],            # EMA r\u00e1pida\n            'rsi_period': [7, 14, 21, 1],\n            'rsi_oversold': [20, 30, 40, 5],\n            'rsi_overbought': [60, 70, 80, 5],\n        }\n        \n        self.tune = {\n            'zigzag_threshold': 0.3,    # 0.3% para scalping 5m (era 1%)\n            'stop_loss_pct': 0.4,       # Stop apertado 0.4%\n            'take_profit_pct': 0.6,     # Take profit 0.6% (ratio 1.5:1)\n            'trend_period': 20,         # EMA mais r\u00e1pida (era 50)\n            'rsi_period': 14,\n            'rsi_oversold': 30,\n            'rsi_overbought': 70,\n        }\n    \n    def calculate_zigzag(self, dataframe, threshold_pct):\n        \"\"\"\n        ZigZag NON-REPAINTING com SINAL DE REVERS\u00c3O\n        \n        Retorna:\n        - zigzag_low: \u00daltimo fundo confirmado\n        - zigzag_high: \u00daltimo topo confirmado\n        - signal: 1 = Novo fundo confirmado (BUY), -1 = Novo topo confirmado (SELL)\n        \"\"\"\n        highs = dataframe['high'].values\n        lows = dataframe['low'].values\n        closes = dataframe['close'].values\n        n = len(dataframe)\n        \n        # Arrays de sa\u00edda\n        zigzag_high = np.full(n, np.nan)  # \u00daltimo topo confirmado\n        zigzag_low = np.full(n, np.nan)   # \u00daltimo fundo confirmado\n        signal = np.zeros(n)  # 0=nada, 1=compra (fundo), -1=venda (topo)\n        \n        # Estado\n        last_confirmed_high = highs[0]\n        last_confirmed_low = lows[0]\n        pending_high = highs[0]\n        pending_low = lows[0]\n        direction = 0  # 0=indefinido, 1=buscando topo, -1=buscando fundo\n        \n        for i in range(1, n):\n            current_high = highs[i]\n            current_low = lows[i]\n            current_close = closes[i]\n            \n            if direction == 0:\n                # Inicializa\u00e7\u00e3o: detectar primeira dire\u00e7\u00e3o\n                if current_close > pending_high * (1 + threshold_pct / 100):\n                    direction = 1  # Subindo, buscando topo\n                    pending_high = current_high\n                elif current_close < pending_low * (1 - threshold_pct / 100):\n                    direction = -1  # Descendo, buscando fundo\n                    pending_low = current_low\n                    \n            elif direction == 1:  # Buscando TOPO\n                # Atualizar topo pendente se fizer nova m\u00e1xima\n                if current_high > pending_high:\n                    pending_high = current_high\n                \n                # CONFIRMA\u00c7\u00c3O DE TOPO: Pre\u00e7o recuou threshold% do topo pendente\n                if current_close < pending_high * (1 - threshold_pct / 100):\n                    last_confirmed_high = pending_high\n                    direction = -1  # Agora buscando fundo\n                    pending_low = current_low\n                    signal[i] = -1  # SINAL DE VENDA (topo confirmado)\n                    \n            elif direction == -1:  # Buscando FUNDO\n                # Atualizar fundo pendente se fizer nova m\u00ednima\n                if current_low < pending_low:\n                    pending_low = current_low\n                \n                # CONFIRMA\u00c7\u00c3O DE FUNDO: Pre\u00e7o subiu threshold% do fundo pendente\n                if current_close > pending_low * (1 + threshold_pct / 100):\n                    last_confirmed_low = pending_low\n                    direction = 1  # Agora buscando topo\n                    pending_high = current_high\n                    signal[i] = 1  # SINAL DE COMPRA (fundo confirmado)\n            \n            # Salvar estado da estrutura no candle atual\n            zigzag_high[i] = last_confirmed_high\n            zigzag_low[i] = last_confirmed_low\n        \n        return zigzag_low, zigzag_high, signal\n    \n    def indicators(self, candles):\n        \"\"\"\n        Calcula ZigZag REAL + EMA de tend\u00eancia\n        \"\"\"\n        # Converter dict de arrays para DataFrame\n        df = pd.DataFrame({\n            'high': candles['high'],\n            'low': candles['low'],\n            'close': candles['close'],\n        })\n        \n        threshold = float(self.tune[\"zigzag_threshold\"])\n        trend_period = int(self.tune[\"trend_period\"])\n        rsi_period = int(self.tune[\"rsi_period\"])\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # ZIGZAG NON-REPAINTING - Topos e fundos confirmados + SINAL\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        zigzag_low, zigzag_high, zigzag_signal = self.calculate_zigzag(df, threshold)\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # EMA DE TEND\u00caNCIA - Filtro para n\u00e3o operar contra tend\u00eancia\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        ema_trend = df['close'].ewm(span=trend_period, adjust=False).mean().values\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # RSI - Confirma revers\u00e3o (sobrevendido = fundo real)\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        delta = df['close'].diff()\n        gain = (delta.where(delta > 0, 0)).rolling(window=rsi_period).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=rsi_period).mean()\n        rs = gain / loss\n        rsi = 100 - (100 / (1 + rs))\n        rsi_values = rsi.values\n        \n        return {\n            'zigzag_line': zigzag_low,        # \u00daltimo fundo confirmado (Suporte)\n            'zigzag_high': zigzag_high,       # \u00daltimo topo confirmado (Resist\u00eancia)\n            'zigzag_signal': zigzag_signal,   # 1=BUY (novo fundo), -1=SELL (novo topo)\n            'ema_trend': ema_trend,           # EMA para filtro de tend\u00eancia\n            'rsi': rsi_values,                # RSI para confirmar revers\u00e3o\n            'close': df['close'].values,      # Pre\u00e7o de fechamento\n        }\n    \n    def strategy(self, tick_info, indicators):\n        \"\"\"\n        Estrat\u00e9gia ZigZag Reversal Trading (Institucional)\n        \n        L\u00d3GICA:\n        - COMPRA quando signal == 1 (novo fundo confirmado)\n        - VENDA quando signal == -1 (novo topo confirmado) OU Stop Loss\n        \"\"\"\n        # Extrair valores\n        def get_value(val, idx=-1):\n            if isinstance(val, (np.ndarray, list)):\n                if len(val) >= abs(idx):\n                    return val[idx]\n                return np.nan\n            return val\n        \n        # Sinal de revers\u00e3o do ZigZag\n        zigzag_signal = get_value(indicators.get('zigzag_signal'))\n        zigzag_high = get_value(indicators.get('zigzag_high'))\n        current_price = tick_info.get('close')\n        last_trade = tick_info.get('last_trade')\n        \n        # Valida\u00e7\u00f5es\n        if current_price is None or np.isnan(zigzag_signal):\n            return qx.Hold()\n        \n        # Par\u00e2metros\n        stop_loss_pct = float(self.tune[\"stop_loss_pct\"])\n        take_profit_pct = float(self.tune[\"take_profit_pct\"])\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # SEM POSI\u00c7\u00c3O - Buscar entrada\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        if last_trade is None or isinstance(last_trade, qx.Sell):\n            # COMPRA: Sinal de fundo confirmado (revers\u00e3o de baixa para alta)\n            if zigzag_signal == 1:\n                return qx.Buy()\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # COM POSI\u00c7\u00c3O - Gerenciar sa\u00edda\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        elif isinstance(last_trade, qx.Buy):\n            entry_price = last_trade.price\n            \n            # STOP LOSS: Sa\u00edda for\u00e7ada se pre\u00e7o cair demais\n            stop_price = entry_price * (1 - stop_loss_pct / 100)\n            if current_price <= stop_price:\n                return qx.Sell()\n            \n            # TAKE PROFIT: Sa\u00edda em lucro fixo\n            take_price = entry_price * (1 + take_profit_pct / 100)\n            if current_price >= take_price:\n                return qx.Sell()\n            \n            # SINAL DE TOPO: ZigZag confirmou novo topo (hora de sair)\n            if zigzag_signal == -1:\n                return qx.Sell()\n            \n            # RESIST\u00caNCIA: Pre\u00e7o chegou no \u00faltimo topo confirmado\n            if not np.isnan(zigzag_high) and current_price >= zigzag_high * 0.995:\n                return qx.Sell()\n        \n        return qx.Hold()\n    \n    def plot(self, *args):\n        \"\"\"Plotagem dos indicadores\"\"\"\n        qx.plot(\n            self.info,\n            *args,\n            (\n                (\"zigzag_line\", \"Suporte (Fundo)\", \"lime\", 0, \"Main\"),\n                (\"zigzag_high\", \"Resist\u00eancia (Topo)\", \"red\", 0, \"Main\"),\n                (\"ema_trend\", \"EMA Trend\", \"orange\", 0, \"Main\"),\n            ),\n        )\n    \n\n\n    def fitness(self, states, raw_states, asset, currency):\n        \"\"\"M\u00e9tricas de performance para otimiza\u00e7\u00e3o\"\"\"\n        return [\n            \"roi_assets\",\n            \"roi_currency\",\n            \"roi\",\n            \"cagr\",\n            \"sortino\", \n            \"maximum_drawdown\",\n            \"trade_win_rate\",\n        ], {}\n\n\n# ===========================================================================\n# CONFIGURA\u00c7\u00c3O GLOBAL\n# ===========================================================================\n# 60=1m, 300=5m, 900=15m, 3600=1h, 14400=4h, 86400=1d\nTIMEFRAME = 3600  # 15 minutos (900 segundos)\nFEE = 0.1  # 0.1%\n\n\n# ===========================================================================\n# MAIN\n# ===========================================================================\ndef main():\n    \"\"\"Configura e executa a estrat\u00e9gia.\"\"\"\n    import time\n    asset, currency = \"SOL\", \"USDT\"\n    wallet = qx.PaperWallet({asset: 0, currency: 10000}, fee=FEE)\n    \n    data = qx.Data(\n        exchange=\"binance\",\n        asset=asset,\n        currency=currency,\n        begin=\"2025-06-01\",\n        #end=\"2026-01-14\",  # Data fixa (opcional)\n        end=int(time.time()),  # Dados at\u00e9 o segundo atual\n        candle_size=TIMEFRAME, \n    )\n    # python strategies/ZigZagPivots.py\n    bot = ZigZagPivots()\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()\n\n    \n",
 "BEST ROI TUNE_Thu Jan 22 16:20:31 2026_SOL_USDT_3600_Thu Jan 22 16:20:31 2026": {
  "identifier": "BEST ROI TUNE_Thu Jan 22 16:20:31 2026_SOL_USDT_3600_Thu Jan 22 16:20:31 2026",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 3600,
  "tune": {
   "zigzag_threshold": 0.6941647333013425,
   "stop_loss_pct": 0.2,
   "take_profit_pct": 0.8022587645607475,
   "trend_period": 50,
   "rsi_period": 10,
   "rsi_oversold": 28.065075949280402,
   "rsi_overbought": 65.57021892800826
  },
  "results": {
   "roi": 0.16102753263547298,
   "roi_assets": 0.1950534709884943,
   "roi_currency": 0.16102753263547298,
   "cagr": -0.9314646924976945,
   "maximum_drawdown": 0.8301592822847575,
   "trade_win_rate": 0.3871576959395656
  }
 }
}