{
 "source": "\"\"\"\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551       ZIGZAG MOMENTUM PRO - BASEADO EM SOLU\u00c7\u00c3O TRADINGVIEW VALIDADA       \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                           \u2551\n\u2551 ALGORITMO PROFISSIONAL (Momentum-Based ZigZag):                           \u2551\n\u2551                                                                           \u2551\n\u2551 1. N\u00c3O USA LOOKAHEAD - Detecta revers\u00f5es via MOMENTUM em tempo real      \u2551\n\u2551 2. Quando momentum inverte \u2192 captura o extremo da \u00faltima perna           \u2551\n\u2551 3. Piv\u00f4 \u00e9 confirmado NO MOMENTO da invers\u00e3o de momentum                  \u2551\n\u2551 4. 100% NON-REPAINTING - Sinal aparece uma vez e nunca muda             \u2551\n\u2551                                                                           \u2551\n\u2551 BASEADO EM:                                                               \u2551\n\u2551 - \"Momentum-based ZigZag NON-REPAINTING\" (Peter_O - TradingView)         \u2551\n\u2551 - Usa RSI/MACD como detector de invers\u00e3o de momentum                     \u2551\n\u2551 - Validado por milhares de traders profissionais                         \u2551\n\u2551                                                                           \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\"\"\"\n\nimport qtradex as qx\nimport numpy as np\nimport time\n\n\nclass ZigZagMomentum(qx.BaseBot):\n    \"\"\"\n    ZigZag Momentum Pro - Detec\u00e7\u00e3o Institucional baseada em Momentum.\n    \n    Algoritmo validado: Detecta invers\u00e3o de momentum para confirmar piv\u00f4s,\n    sem lookahead, garantindo que backtest = live.\n    \"\"\"\n    \n    def __init__(self):\n        self.timeframe = TIMEFRAME\n        self.fee = FEE\n        self.warmup = 100\n        \n        # ===================================================================\n        # TUNE: Par\u00e2metros Profissionais\n        # ===================================================================\n        self.tune = {\n            # Momentum Detection (RSI-based)\n            \"rsi_period\": 14,          # Per\u00edodo do RSI\n            \"rsi_smoothing\": 5,        # Suaviza\u00e7\u00e3o do RSI (QQE-style)\n            \n            # Swing Validation\n            \"atr_period\": 14,          # ATR para valida\u00e7\u00e3o de movimento\n            \"min_swing_atr\": 1.0,      # Movimento m\u00ednimo em ATR para swing v\u00e1lido\n            \n            # Trend Filter\n            \"ema_trend\": 50,           # EMA para filtro de tend\u00eancia\n            \n            # Risk Management\n            \"stop_atr_mult\": 2.0,      # ATR multiplicador para stop\n        }\n        \n        # ===================================================================\n        # CLAMPS: Ranges para Otimiza\u00e7\u00e3o\n        # ===================================================================\n        self.clamps = {\n            \"rsi_period\":       [7, 14, 21, 2],\n            \"rsi_smoothing\":    [3, 5, 10, 1],\n            \"atr_period\":       [7, 14, 28, 3],\n            \"min_swing_atr\":    [0.5, 1.0, 2.5, 0.25],\n            \"ema_trend\":        [20, 50, 100, 10],\n            \"stop_atr_mult\":    [1.0, 2.0, 4.0, 0.5],\n        }\n    \n    \n    def indicators(self, candles):\n        \"\"\"\n        ZIGZAG BASEADO EM MOMENTUM - 100% NON-REPAINTING\n        \n        Algoritmo:\n        1. Calcula RSI suavizado (estilo QQE)\n        2. Detecta cruzamentos de momentum (invers\u00f5es)\n        3. Quando momentum inverte \u2192 confirma o extremo anterior como piv\u00f4\n        4. Sinal gerado imediatamente (sem delay)\n        \"\"\"\n        highs = np.array(candles['high'])\n        lows = np.array(candles['low'])\n        closes = np.array(candles['close'])\n        n = len(highs)\n        \n        # Par\u00e2metros\n        rsi_period = int(self.tune[\"rsi_period\"])\n        rsi_smooth = int(self.tune[\"rsi_smoothing\"])\n        atr_period = int(self.tune[\"atr_period\"])\n        min_swing_atr = float(self.tune[\"min_swing_atr\"])\n        ema_period = int(self.tune[\"ema_trend\"])\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # INDICADORES BASE\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        rsi = qx.ti.rsi(closes, rsi_period)\n        rsi_smooth_line = qx.ti.ema(rsi, rsi_smooth)  # RSI suavizado (QQE-style)\n        atr = qx.ti.atr(candles['high'], candles['low'], candles['close'], atr_period)\n        ema = qx.ti.ema(closes, ema_period)\n        \n        # Arrays de sa\u00edda\n        pivot_high = np.full(n, np.nan)\n        pivot_low = np.full(n, np.nan)\n        zigzag_line = np.full(n, np.nan)\n        struct_h = np.full(n, np.nan)\n        struct_l = np.full(n, np.nan)\n        trend = np.zeros(n)\n        signal = np.full(n, None, dtype=object)\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # DETEC\u00c7\u00c3O DE MOMENTUM (RSI Crossover do n\u00edvel 50)\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        momentum_up = np.zeros(n, dtype=bool)    # RSI cruzou acima de 50\n        momentum_down = np.zeros(n, dtype=bool)  # RSI cruzou abaixo de 50\n        \n        for i in range(1, n):\n            if not np.isnan(rsi_smooth_line[i]) and not np.isnan(rsi_smooth_line[i-1]):\n                # Momentum UP: RSI cruza acima de 50\n                if rsi_smooth_line[i] > 50 and rsi_smooth_line[i-1] <= 50:\n                    momentum_up[i] = True\n                # Momentum DOWN: RSI cruza abaixo de 50\n                elif rsi_smooth_line[i] < 50 and rsi_smooth_line[i-1] >= 50:\n                    momentum_down[i] = True\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # CONSTRUIR ZIGZAG BASEADO EM MOMENTUM\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        direction = 0  # 0=indefinido, 1=buscando topo, -1=buscando fundo\n        \n        # Rastreamento de extremos\n        tracked_high = highs[0]\n        tracked_high_idx = 0\n        tracked_low = lows[0]\n        tracked_low_idx = 0\n        \n        # Hist\u00f3rico de piv\u00f4s confirmados\n        confirmed_highs = []\n        confirmed_lows = []\n        \n        for i in range(1, n):\n            current_atr = atr[i] if not np.isnan(atr[i]) and atr[i] > 0 else np.nanmean(atr)\n            min_swing = current_atr * min_swing_atr\n            \n            # Atualizar extremos rastreados\n            if highs[i] > tracked_high:\n                tracked_high = highs[i]\n                tracked_high_idx = i\n            if lows[i] < tracked_low:\n                tracked_low = lows[i]\n                tracked_low_idx = i\n            \n            # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n            # MOMENTUM UP \u2192 CONFIRMA FUNDO (Fim de perna de baixa)\n            # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n            if momentum_up[i]:\n                # Validar movimento m\u00ednimo\n                if len(confirmed_highs) == 0 or (confirmed_highs[-1][1] - tracked_low) >= min_swing:\n                    # FUNDO CONFIRMADO\n                    pivot_low[tracked_low_idx] = tracked_low\n                    zigzag_line[tracked_low_idx] = tracked_low\n                    confirmed_lows.append((tracked_low_idx, tracked_low))\n                    \n                    # Gerar sinal de COMPRA\n                    signal[i] = 'buy'\n                    \n                    # Estrutura de mercado\n                    if len(confirmed_lows) >= 2:\n                        if tracked_low > confirmed_lows[-2][1]:\n                            trend[i:] = 1  # Higher Low = Uptrend\n                        else:\n                            trend[i:] = -1  # Lower Low = Downtrend\n                    \n                    # Reset rastreamento\n                    direction = 1  # Agora buscando topo\n                    tracked_high = highs[i]\n                    tracked_high_idx = i\n                \n                struct_l[i:] = tracked_low\n            \n            # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n            # MOMENTUM DOWN \u2192 CONFIRMA TOPO (Fim de perna de alta)\n            # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n            elif momentum_down[i]:\n                # Validar movimento m\u00ednimo\n                if len(confirmed_lows) == 0 or (tracked_high - confirmed_lows[-1][1]) >= min_swing:\n                    # TOPO CONFIRMADO\n                    pivot_high[tracked_high_idx] = tracked_high\n                    zigzag_line[tracked_high_idx] = tracked_high\n                    confirmed_highs.append((tracked_high_idx, tracked_high))\n                    \n                    # Gerar sinal de VENDA\n                    signal[i] = 'sell'\n                    \n                    # Estrutura de mercado\n                    if len(confirmed_highs) >= 2:\n                        if tracked_high > confirmed_highs[-2][1]:\n                            trend[i:] = 1  # Higher High = Uptrend\n                        else:\n                            trend[i:] = -1  # Lower High = Downtrend\n                    \n                    # Reset rastreamento\n                    direction = -1  # Agora buscando fundo\n                    tracked_low = lows[i]\n                    tracked_low_idx = i\n                \n                struct_h[i:] = tracked_high\n        \n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        # INTERPOLAR LINHA ZIGZAG (Visual)\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        last_v_idx = None\n        for i in range(n):\n            if not np.isnan(zigzag_line[i]):\n                if last_v_idx is not None and i > last_v_idx:\n                    p1, p2 = zigzag_line[last_v_idx], zigzag_line[i]\n                    dist = i - last_v_idx\n                    for j in range(last_v_idx + 1, i):\n                        zigzag_line[j] = p1 + (j - last_v_idx) * (p2 - p1) / dist\n                last_v_idx = i\n        \n        return {\n            'atr': atr,\n            'rsi': rsi_smooth_line,\n            'ema': ema,\n            'zigzag_line': zigzag_line,\n            'pivot_high': pivot_high,\n            'pivot_low': pivot_low,\n            'struct_h': struct_h,\n            'struct_l': struct_l,\n            'trend': trend,\n            'signal': signal,\n        }\n    \n    \n    # =========================================================================\n    # ESTRAT\u00c9GIA PROFISSIONAL\n    # =========================================================================\n    \n    def strategy(self, tick_info, indicators):\n        \"\"\"\n        Estrat\u00e9gia Institucional: Opera piv\u00f4s confirmados por momentum\n        \n        COMPRA: Fundo confirmado (momentum_up) + Tend\u00eancia OK\n        VENDA: Topo confirmado (momentum_down) + Tend\u00eancia OK\n        \"\"\"\n        close = tick_info.get('close')\n        last_trade = tick_info.get('last_trade')\n        \n        # Sinais de piv\u00f4\n        sig = indicators.get('signal')\n        if isinstance(sig, (np.ndarray, list)): sig = sig[-1]\n        \n        # Tend\u00eancia estrutural\n        trnd = indicators.get('trend')\n        if isinstance(trnd, (np.ndarray, list)): trnd = trnd[-1]\n        \n        # EMA trend\n        ema = indicators.get('ema')\n        if isinstance(ema, (np.ndarray, list)): ema = ema[-1]\n        \n        # N\u00edveis\n        res = indicators.get('struct_h')\n        sup = indicators.get('struct_l')\n        if isinstance(res, (np.ndarray, list)): res = res[-1]\n        if isinstance(sup, (np.ndarray, list)): sup = sup[-1]\n        \n        atr_array = indicators.get('atr')\n        current_atr = atr_array[-1] if isinstance(atr_array, (np.ndarray, list)) else atr_array\n        stop_mult = self.tune.get('stop_atr_mult', 2.0)\n\n        # Filtro de tend\u00eancia EMA\n        above_ema = close > ema if not np.isnan(ema) else True\n        below_ema = close < ema if not np.isnan(ema) else True\n\n        # 1. GEST\u00c3O DE RISCO\n        if isinstance(last_trade, qx.Buy):\n            stop = sup if not np.isnan(sup) else (last_trade.price - current_atr * stop_mult)\n            if close < stop:\n                return qx.Sell()\n            \n        elif isinstance(last_trade, qx.Sell):\n            stop = res if not np.isnan(res) else (last_trade.price + current_atr * stop_mult)\n            if close > stop:\n                return qx.Buy()\n\n        # 2. SINAIS DE PIV\u00d4 + FILTROS\n        if sig == 'buy':\n            # Compra se: sinal de fundo + (tend\u00eancia >= 0 OU pre\u00e7o acima da EMA)\n            if trnd >= 0 or above_ema:\n                if last_trade is None or isinstance(last_trade, qx.Sell):\n                    return qx.Buy()\n        \n        elif sig == 'sell':\n            # Venda se: sinal de topo + (tend\u00eancia <= 0 OU pre\u00e7o abaixo da EMA)\n            if trnd <= 0 or below_ema:\n                if isinstance(last_trade, qx.Buy):\n                    return qx.Sell()\n        \n        return qx.Hold()\n    \n    \n    # =========================================================================\n    # VISUALIZA\u00c7\u00c3O\n    # =========================================================================\n    \n    def plot(self, data, states, indicators, block):\n        qx.plot(\n            self.info,\n            data,\n            states,\n            indicators,\n            block,\n            (\n                (\"zigzag_line\", \"ZigZag\", \"cyan\", 0, \"ZigZag Momentum\"),\n                (\"ema\", \"EMA Trend\", \"yellow\", 0, None),\n                (\"struct_h\", \"Resist\u00eancia\", \"red\", 0, None),\n                (\"struct_l\", \"Suporte\", \"lime\", 0, None),\n                (\"pivot_high\", \"\u25b2 Topo\", \"white\", 0, None),\n                (\"pivot_low\", \"\u25bc Fundo\", \"white\", 0, None),\n                (\"rsi\", \"RSI Smooth\", \"orange\", 1, \"Momentum\"),\n                (\"atr\", \"ATR\", \"white\", 2, \"Volatilidade\"),\n            ),\n        )\n        qx.plotmotion(block)\n    \n    def execution(self, signal, indicators, wallet):\n        if isinstance(signal, qx.Buy):\n            return qx.Buy()\n        elif isinstance(signal, qx.Sell):\n            return qx.Sell()\n        return signal\n    \n    def fitness(self, states, raw_states, asset, currency):\n        return [\n            \"roi_currency\",\n            \"roi\",\n            \"cagr\",\n            \"sortino\",\n            \"maximum_drawdown\",\n            \"trade_win_rate\",\n        ], {}\n\n\n# ===========================================================================\n# CONFIGURA\u00c7\u00c3O GLOBAL\n# ===========================================================================\nTIMEFRAME = 300  # 5min\nFEE = 0.1  # 0.1%\n\n\n# ===========================================================================\n# MAIN\n# ===========================================================================\ndef main():\n    import time\n    asset, currency = \"SOL\", \"USDT\"\n    wallet = qx.PaperWallet({asset: 0, currency: 10000}, fee=FEE)\n    \n    data = qx.Data(\n        exchange=\"binance\",\n        asset=asset,\n        currency=currency,\n        begin=\"2025-11-01\",\n        end=int(time.time()),\n        candle_size=TIMEFRAME, \n    )\n    # python strategies/ZigZagMomentum.py\n    bot = ZigZagMomentum()\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()\n",
 "BEST ROI TUNE_Sat Jan 24 19:11:56 2026_SOL_USDT_300_Sat Jan 24 19:11:56 2026": {
  "identifier": "BEST ROI TUNE_Sat Jan 24 19:11:56 2026_SOL_USDT_300_Sat Jan 24 19:11:56 2026",
  "begin_date": "01/11/2025",
  "end_date": "24/01/2026",
  "duration": "2 Meses e 24 Dias",
  "asset": "SOL",
  "currency": "USDT",
  "timeframe": 300,
  "tune": {
   "rsi_period": 12,
   "rsi_smoothing": 4,
   "atr_period": 15,
   "min_swing_atr": 0.6780043949787848,
   "ema_trend": 20,
   "stop_atr_mult": 1.0290411610186425
  },
  "results": {
   "roi": 1.033698728076923,
   "roi_currency": 1.033698728076923,
   "cagr": 1.6387324833333201,
   "maximum_drawdown": 0.08745253246670474,
   "trade_win_rate": 1.0
  }
 }
}